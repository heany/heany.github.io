<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知微</title>
  
  <subtitle>一盏灯，一个人，亮着的屏幕，游走的灵魂。!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://heany.github.io/"/>
  <updated>2019-01-26T14:47:30.578Z</updated>
  <id>http://heany.github.io/</id>
  
  <author>
    <name>Heany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql操作使用变量作为表名</title>
    <link href="http://heany.github.io/2018/06/08/mysql%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E8%A1%A8%E5%90%8D/"/>
    <id>http://heany.github.io/2018/06/08/mysql操作使用变量作为表名/</id>
    <published>2018-06-08T02:42:11.000Z</published>
    <updated>2019-01-26T14:47:30.578Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>版权声明：本文为博主原创文章，未经博主允许不得转载。</p></blockquote><p>使用python操作mysql数据库时想实现如下效果：<br>将sql语句中的表名用一个变量代替，实现批量操作表</p><pre><code>sql = &quot;select * from sets where number = &apos;%s&apos; &quot;</code></pre><p>将sql语句中的sets和number用变量代替，实现自动操作多个表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">table = <span class="string">"sets"</span></span><br><span class="line">attr = <span class="string">"number"</span></span><br><span class="line">sql = <span class="string">"select * from "</span>+table+<span class="string">" where "</span>+attr+<span class="string">" = '%s'"</span></span><br><span class="line"><span class="comment"># 成功运行，达到要求</span></span><br></pre></td></tr></table></figure><blockquote><p>其实就是采用字符串操作中的语句拼接技术</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;版权声明：本文为博主原创文章，未经博主允许不得转载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用python操作mysql数据库时想实现如下效果：&lt;br&gt;将sql语句中的表名用一个变量代替，实现批量操作表&lt;/
      
    
    </summary>
    
      <category term="MySQL" scheme="http://heany.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Numpy的random函数汇总</title>
    <link href="http://heany.github.io/2018/06/06/Numpy%E7%9A%84random%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/"/>
    <id>http://heany.github.io/2018/06/06/Numpy的random函数汇总/</id>
    <published>2018-06-06T01:54:44.000Z</published>
    <updated>2019-01-26T14:47:30.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在<code>python</code>数据分析的学习和日常应用过程中，经常要用到<code>numpy</code>库的随机函数，这些随机函数功能很多，经常会混淆记不住～～，每次使用都要去<code>Google</code>，所以我就把常用的随机函数功能汇总在下面了，方便自己查阅。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="二、numpy-random-rand"><a href="#二、numpy-random-rand" class="headerlink" title="二、numpy.random.rand()"></a>二、<code>numpy.random.rand()</code></h2><p>语法：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.rand(d0,d1,...,dn)</span><br><span class="line"><span class="meta"># rand函数根据给定维度生成[0,1)之间的数据，包含0，不包含1</span></span><br><span class="line"><span class="meta"># dn表格每个维度</span></span><br><span class="line"><span class="meta"># 返回值为指定维度的array</span></span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">np.random.rand(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"># output</span><br><span class="line">array([[<span class="number">0.44966653</span> <span class="number">0.52431591</span>]</span><br><span class="line">       [<span class="number">0.12117809</span> <span class="number">0.31425446</span>]</span><br><span class="line">       [<span class="number">0.94938082</span> <span class="number">0.78223903</span>]</span><br><span class="line">       [<span class="number">0.98802125</span> <span class="number">0.01795372</span>]])</span><br><span class="line"></span><br><span class="line">np.random.rand(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">#output</span><br><span class="line">array([[[<span class="number">0.4016697</span>  <span class="number">0.41116077</span>]</span><br><span class="line">        [<span class="number">0.81121991</span> <span class="number">0.18433693</span>]</span><br><span class="line">        [<span class="number">0.94307831</span> <span class="number">0.37959419</span>]]</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.11907587</span> <span class="number">0.97932363</span>]</span><br><span class="line">          [<span class="number">0.20458545</span> <span class="number">0.73305606</span>]</span><br><span class="line">          [<span class="number">0.62938875</span> <span class="number">0.99506056</span>]]</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.85168379</span> <span class="number">0.76133277</span>]</span><br><span class="line">          [<span class="number">0.868105</span>   <span class="number">0.29375361</span>]</span><br><span class="line">          [<span class="number">0.08666713</span> <span class="number">0.43133631</span>]]</span><br><span class="line"></span><br><span class="line">         [[<span class="number">0.93674358</span> <span class="number">0.50061816</span>]</span><br><span class="line">          [<span class="number">0.58272102</span> <span class="number">0.40495383</span>]</span><br><span class="line">          [<span class="number">0.94631605</span> <span class="number">0.51712061</span>]]])</span><br></pre></td></tr></table></figure></p><h2 id="三、numpy-random-randn-返回值具有标准正太分N-0-1"><a href="#三、numpy-random-randn-返回值具有标准正太分N-0-1" class="headerlink" title="三、numpy.random.randn()返回值具有标准正太分N(0,1)"></a>三、<code>numpy.random.randn()</code>返回值具有标准正太分<code>N(0,1)</code></h2><p>语法：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.randn(d0,d1,...,dn)</span><br><span class="line"><span class="meta"># randn函数返回一个或一组样本，具有标准正态分布。</span></span><br><span class="line"><span class="meta"># dn表格每个维度</span></span><br><span class="line"><span class="meta"># 返回值为指定维度的array</span></span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">np.random.randn() # 当没有参数时，返回单个数据</span><br><span class="line"># output</span><br><span class="line"><span class="number">0.10125281554614712</span></span><br><span class="line"></span><br><span class="line">np.random.randn(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"># output</span><br><span class="line">array([[ <span class="number">0.88550167</span>  <span class="number">0.94488988</span>  <span class="number">0.68380494</span> <span class="number">-2.42685228</span>]</span><br><span class="line"> [<span class="number">-0.12320336</span> <span class="number">-0.21325373</span>  <span class="number">0.07526319</span> <span class="number">-0.59034683</span>]])</span><br><span class="line"></span><br><span class="line">np.random.randn(<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"># output</span><br><span class="line">array([[[ <span class="number">1.09663108</span> <span class="number">-0.58652581</span>]</span><br><span class="line">      [<span class="number">-0.94125426</span>  <span class="number">0.01259422</span>]</span><br><span class="line">      [<span class="number">-0.4189963</span>   <span class="number">0.03315681</span>]]</span><br><span class="line"></span><br><span class="line">     [[<span class="number">-0.38388522</span> <span class="number">-0.46672398</span>]</span><br><span class="line">      [ <span class="number">0.35335792</span> <span class="number">-0.92017071</span>]</span><br><span class="line">      [<span class="number">-0.26904716</span>  <span class="number">2.28057168</span>]]</span><br><span class="line"></span><br><span class="line">     [[<span class="number">-0.37893325</span> <span class="number">-0.64560053</span>]</span><br><span class="line">      [ <span class="number">0.93308775</span>  <span class="number">0.68629363</span>]</span><br><span class="line">      [ <span class="number">2.6449362</span>   <span class="number">1.40476443</span>]]</span><br><span class="line"></span><br><span class="line">     [[ <span class="number">1.90709637</span>  <span class="number">0.18952578</span>]</span><br><span class="line">      [<span class="number">-0.09167653</span>  <span class="number">1.95480404</span>]</span><br><span class="line">      [<span class="number">-1.55128951</span> <span class="number">-0.07542736</span>]]])</span><br></pre></td></tr></table></figure></p><h2 id="四、numpy-random-randint"><a href="#四、numpy-random-randint" class="headerlink" title="四、numpy.random.randint()"></a>四、<code>numpy.random.randint()</code></h2><h3 id="4-1、-numpy-random-randint"><a href="#4-1、-numpy-random-randint" class="headerlink" title="4.1、 numpy.random.randint()"></a>4.1、 <code>numpy.random.randint()</code></h3><p>语法：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.randint(low, <span class="attribute">high</span>=None, <span class="attribute">size</span>=None, <span class="attribute">dtype</span>=’l’)</span><br><span class="line"></span><br><span class="line">    返回随机整数，范围区间为[low,high），包含low，不包含high</span><br><span class="line">    参数：low为最小值，high为最大值，size为数组维度大小，dtype为数据类型，默认的数据类型是np.int</span><br><span class="line">    high没有填写时，默认生成随机数的范围是[0，low)</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">np.random.randint(<span class="number">1</span>,size=<span class="number">5</span>) # 返回[<span class="number">0</span>,<span class="number">1</span>)之间的整数，所以只有<span class="number">0</span></span><br><span class="line"># output</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">np.random.randint(<span class="number">1</span>,<span class="number">5</span>) # 返回<span class="number">1</span>个[<span class="number">1</span>,<span class="number">5</span>)时间的随机整数</span><br><span class="line"># output</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">np.random.randint(<span class="number">-5</span>,<span class="number">5</span>,size=(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"># output</span><br><span class="line">array([[<span class="number">-4</span> <span class="number">-5</span>]</span><br><span class="line">       [<span class="number">-2</span> <span class="number">-2</span>]])</span><br></pre></td></tr></table></figure></p><h3 id="4-2、-numpy-random-random-integers"><a href="#4-2、-numpy-random-random-integers" class="headerlink" title="4.2、 numpy.random.random_integers"></a>4.2、 <code>numpy.random.random_integers</code></h3><p>语法：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.random_integers(low, high=<span class="keyword">None</span>, <span class="built_in">size</span>=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    返回随机整数，范围区间为[low,high]，包含low和high</span><br><span class="line">    参数：low为最小值，high为最大值，<span class="built_in">size</span>为数组维度大小</span><br><span class="line">    high没有填写时，默认生成随机数的范围是[<span class="number">1</span>，low]</span><br><span class="line"></span><br><span class="line">该函数在最新的numpy版本中已被替代，建议使用randint函数</span><br></pre></td></tr></table></figure></p><h2 id="五、生成-0-1-之间的浮点数"><a href="#五、生成-0-1-之间的浮点数" class="headerlink" title="五、生成[0,1)之间的浮点数"></a>五、生成<code>[0,1)</code>之间的浮点数</h2><p>语法：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy<span class="selector-class">.random</span><span class="selector-class">.random_sample</span>(size=None)</span><br><span class="line">numpy<span class="selector-class">.random</span><span class="selector-class">.random</span>(size=None)</span><br><span class="line">numpy<span class="selector-class">.random</span><span class="selector-class">.ranf</span>(size=None)</span><br><span class="line">numpy<span class="selector-class">.random</span><span class="selector-class">.sample</span>(size=None)</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'-----------random_sample--------------'</span>)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">random</span>.random_sample(size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'-----------random--------------'</span>)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">random</span>.<span class="built_in">random</span>(size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'-----------ranf--------------'</span>)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">random</span>.ranf(size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'-----------sample--------------'</span>)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">random</span>.sample(size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"># <span class="built_in">output</span></span><br><span class="line"><span class="comment">-----------random_sample--------------</span></span><br><span class="line"><span class="string">[[0.73845538 0.57461322]</span></span><br><span class="line"><span class="string"> [0.50090024 0.12809794]]</span></span><br><span class="line"><span class="comment">-----------random--------------</span></span><br><span class="line"><span class="string">[[0.65293998 0.15751317]</span></span><br><span class="line"><span class="string"> [0.0745293  0.03874293]]</span></span><br><span class="line"><span class="comment">-----------ranf--------------</span></span><br><span class="line"><span class="string">[[0.75927288 0.79548232]</span></span><br><span class="line"><span class="string"> [0.47618339 0.04334719]]</span></span><br><span class="line"><span class="comment">-----------sample--------------</span></span><br><span class="line"><span class="string">[[0.81010338 0.59291716]</span></span><br><span class="line"><span class="string"> [0.58648785 0.1767814 ]]</span></span><br></pre></td></tr></table></figure></p><h2 id="六、-numpy-random-choice"><a href="#六、-numpy-random-choice" class="headerlink" title="六、 numpy.random.choice()"></a>六、 <code>numpy.random.choice()</code></h2><p>语法：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.choice(a, <span class="attribute">size</span>=None, <span class="attribute">replace</span>=<span class="literal">True</span>, <span class="attribute">p</span>=None)</span><br><span class="line"></span><br><span class="line">    从给定的一维数组中生成随机数</span><br><span class="line">    参数： a为一维数组类似数据或整数；size为数组维度；p为数组中的数据出现的概率</span><br><span class="line">    a为整数时，对应的一维数组为np.arange(a)</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">np.<span class="built_in">random</span>.choice(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="keyword">array</span>([<span class="number">4</span> <span class="number">4</span> <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">np.<span class="built_in">random</span>.choice(<span class="number">5</span>, <span class="number">3</span>, replace=False)</span><br><span class="line"># 当replace为False时，生成的随机数不能有重复的数值</span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="keyword">array</span>([<span class="number">4</span> <span class="number">2</span> <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">np.<span class="built_in">random</span>.choice(<span class="number">5</span>,<span class="built_in">size</span>=(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"><span class="meta"># output</span></span><br><span class="line">[[<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">demo_list = [<span class="string">'lenovo'</span>, <span class="string">'sansumg'</span>,<span class="string">'moto'</span>,<span class="string">'xiaomi'</span>, <span class="string">'iphone'</span>]</span><br><span class="line">np.<span class="built_in">random</span>.choice(demo_list,<span class="built_in">size</span>=(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="keyword">array</span>([[<span class="string">'sansumg'</span> <span class="string">'iphone'</span> <span class="string">'moto'</span>]</span><br><span class="line">       [<span class="string">'moto'</span> <span class="string">'iphone'</span> <span class="string">'iphone'</span>]</span><br><span class="line">       [<span class="string">'xiaomi'</span> <span class="string">'iphone'</span> <span class="string">'xiaomi'</span>]])</span><br></pre></td></tr></table></figure></p><pre><code>参数p的长度与参数a的长度需要一致；参数p为概率，p里的数据之和应为1</code></pre><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo_list = [<span class="string">'lenovo'</span>, <span class="string">'sansumg'</span>,<span class="string">'moto'</span>,<span class="string">'xiaomi'</span>, <span class="string">'iphone'</span>]</span><br><span class="line">np.random.choice(demo_list,size=(<span class="number">3</span>,<span class="number">3</span>), p=[<span class="number">0.1</span>,<span class="number">0.6</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>])</span><br><span class="line"># output</span><br><span class="line">array([[<span class="string">'moto'</span> <span class="string">'sansumg'</span> <span class="string">'xiaomi'</span>]</span><br><span class="line">       [<span class="string">'lenovo'</span> <span class="string">'moto'</span> <span class="string">'sansumg'</span>]</span><br><span class="line">       [<span class="string">'sansumg'</span> <span class="string">'sansumg'</span> <span class="string">'sansumg'</span>]])</span><br></pre></td></tr></table></figure><h2 id="七、numpy-random-seed"><a href="#七、numpy-random-seed" class="headerlink" title="七、numpy.random.seed()"></a>七、<code>numpy.random.seed()</code></h2><p>语法：</p><pre><code>np.random.seed()的作用：使得随机数据可预测。当我们设置相同的seed，每次生成的随机数相同。如果不设置seed，则每次会生成不同的随机数</code></pre><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">np.random.rand(<span class="number">5</span>)</span><br><span class="line"># output</span><br><span class="line">array([<span class="number">0.5488135</span> , <span class="number">0.71518937</span>, <span class="number">0.60276338</span>, <span class="number">0.54488318</span>, <span class="number">0.4236548</span> ])</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1676</span>)</span><br><span class="line">np.random.rand(<span class="number">5</span>)</span><br><span class="line"># output</span><br><span class="line">array([<span class="number">0.39983389</span>, <span class="number">0.29426895</span>, <span class="number">0.89541728</span>, <span class="number">0.71807369</span>, <span class="number">0.3531823</span> ])</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1676</span>)</span><br><span class="line">np.random.rand(<span class="number">5</span>)</span><br><span class="line"># output</span><br><span class="line">array([<span class="number">0.39983389</span>, <span class="number">0.29426895</span>, <span class="number">0.89541728</span>, <span class="number">0.71807369</span>, <span class="number">0.3531823</span> ])</span><br></pre></td></tr></table></figure><h2 id="八、结束语"><a href="#八、结束语" class="headerlink" title="八、结束语"></a>八、结束语</h2><p>嗯？～～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;python&lt;/code&gt;数据分析的学习和日常应用过程中，经常要用到&lt;code&gt;numpy&lt;/code&gt;库的随
      
    
    </summary>
    
      <category term="Machine Learning" scheme="http://heany.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Numpy Random" scheme="http://heany.github.io/tags/Numpy-Random/"/>
    
  </entry>
  
  <entry>
    <title>Nginx+PHP+MySQL搭建过程</title>
    <link href="http://heany.github.io/2018/05/15/Nginx-PHP-MySQL%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://heany.github.io/2018/05/15/Nginx-PHP-MySQL搭建过程/</id>
    <published>2018-05-15T08:43:10.000Z</published>
    <updated>2019-01-26T14:47:30.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h2><p>&emsp;最近要开始干活了～老板要求边做边写开发文档，啊啊啊啊，就把这一系列的文档发在博客里面吧，需要的时候再来拿，还能凑几篇博客。这是第一篇，关于Nginx+php+MySQL环境搭建的，很简单网上很多～～～<br><a id="more"></a></p><h2 id="二、-本机环境"><a href="#二、-本机环境" class="headerlink" title="二、 本机环境"></a>二、 本机环境</h2><ul><li>OS: Ubuntu 17.10.1_x64</li><li>Nginx_version: nginx/1.12.1</li><li>PHP_version: PHP-7.1.17</li><li>MySQL_version: mysql5.7.22</li></ul><h2 id="三、-安装步骤"><a href="#三、-安装步骤" class="headerlink" title="三、 安装步骤"></a>三、 安装步骤</h2><h3 id="3-1、-安装Nginx-Web-Server"><a href="#3-1、-安装Nginx-Web-Server" class="headerlink" title="3.1、 安装Nginx Web Server"></a>3.1、 安装<code>Nginx Web Server</code></h3><p>直接使用<code>apt package management</code>来完成安装，命令如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> upgrade</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等一会儿就安装好了，下面是一些重要的文件目录</span></span><br><span class="line">nginx的配置文件目录： /etc/nginx;</span><br><span class="line">Nginx的缓存目录： /var/cache/nginx;</span><br><span class="line">Nginx的日志目录： /var/log/nginx;</span><br></pre></td></tr></table></figure><blockquote><h1 id="启动nginx服务"><a href="#启动nginx服务" class="headerlink" title="启动nginx服务"></a>启动nginx服务</h1><p>   sudo systemctl start nginx</p><h1 id="test"><a href="#test" class="headerlink" title="test"></a>test</h1><p>   #打开网页，输入<code>http://localhost</code>可以看到<code>welcome to nginx</code>字样</p></blockquote><h3 id="3-2、-安装MySQL管理网站数据"><a href="#3-2、-安装MySQL管理网站数据" class="headerlink" title="3.2、 安装MySQL管理网站数据"></a>3.2、 安装MySQL管理网站数据</h3><p>同样是使用<code>ubuntu</code>中的<code>apt</code>包管理器来安装，命令如下：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line"># 会弹框提醒输入root密码，直接输入然后按`Enter`，结束。</span><br></pre></td></tr></table></figure></p><h3 id="3-3、-安装PHP服务"><a href="#3-3、-安装PHP服务" class="headerlink" title="3.3、 安装PHP服务"></a>3.3、 安装<code>PHP</code>服务</h3><p>同样是使用<code>ubuntu</code>中的<code>apt</code>包管理器来安装，命令如下：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 顺便把php-mysql插件装上</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> install php-fpm php-mysql</span><br><span class="line"></span><br><span class="line"><span class="meta"># 一些重要的文件目录</span></span><br><span class="line"><span class="meta"># php配置文件路径： /etc/php/7.1/fpm/php.ini</span></span><br></pre></td></tr></table></figure></p><p>然后，修改<code>php</code>的配置文件：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 切换到php配置目录</span><br><span class="line">cd /etc/php/7.1/fpm</span><br><span class="line"># 修改配置文件</span><br><span class="line">sudo vim php.ini</span><br><span class="line"><span class="code">+++</span>+</span><br><span class="line">找到这行，取消注释，将1改成0</span><br><span class="line">cgi.fix<span class="emphasis">_pathinfo=0</span></span><br><span class="line"><span class="emphasis">++++</span></span><br></pre></td></tr></table></figure></p><p>最后，重启<code>php</code>服务<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">systemctl</span> <span class="selector-tag">restart</span> <span class="selector-tag">php-7</span><span class="selector-class">.1-fpm</span></span><br></pre></td></tr></table></figure></p><h3 id="3-4、-配置Nginx去使用PHP处理器"><a href="#3-4、-配置Nginx去使用PHP处理器" class="headerlink" title="3.4、 配置Nginx去使用PHP处理器"></a>3.4、 配置<code>Nginx</code>去使用<code>PHP</code>处理器</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到nginx网站的配置目录</span></span><br><span class="line">cd /etc/nginx/sites-available</span><br><span class="line">sudo vim default</span><br><span class="line"><span class="comment"># 做如下修改：</span></span><br><span class="line">++++</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">    root /var/www/html;</span><br><span class="line">    index index.php index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">    server_name server_domain_or_IP;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        include snippets/fastcgi-php.conf;</span><br><span class="line">        fastcgi_pass unix:/run/php/php7.1-fpm.sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /\.ht &#123;</span><br><span class="line">        deny all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">++++</span><br></pre></td></tr></table></figure><p><b style="color: red">这里有个小坑，了解一下：</b><b>由于安装的php版本是<code>php7.1</code>，安装<code>nginx</code>默认配置文件里面使用的是<code>/run/php/php7.0-fpm.sock</code>,你在<code>/run/php</code>中找不到<code>php7.0</code>的sock文件。所以，这里我们要把它修改为我们安装的<code>php</code>相应版本的<code>sock</code>文件。即</b><b style="color: red"><code>/run/php/php7.1-fpm.sock;</code></b></p><p>然后，测试配置文件是否生效。</p><pre><code>sudo nginx -t  #如果没报错，说明配置成功</code></pre><p>最后，重新加载<code>nginx</code>服务器</p><pre><code>sudo systemctl reload nginx</code></pre><h3 id="3-5、-测试nginx和PHP配置是否生效"><a href="#3-5、-测试nginx和PHP配置是否生效" class="headerlink" title="3.5、 测试nginx和PHP配置是否生效"></a>3.5、 测试<code>nginx</code>和<code>PHP</code>配置是否生效</h3><p>在网站的根目录<code>/var/www/html</code>下新建一个<code>info.php</code>文件，写入一下内容：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// info.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后，打开浏览器，输入<code>localhost/info.php</code>，会看到输出了之前安装的<code>php</code>的版本信息和其他模块的详细信息。这 就 表 明 <code>Nginx</code> 和<code>PHP</code>都安装和配置～～成功了！！！</p><h2 id="四、-结束语"><a href="#四、-结束语" class="headerlink" title="四、 结束语"></a>四、 结束语</h2><p>路很长～这才刚刚开始啊～～～～</p><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-in-ubuntu-16-04" target="_blank" rel="noopener">参考自博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、-前言&quot;&gt;&lt;a href=&quot;#一、-前言&quot; class=&quot;headerlink&quot; title=&quot;一、 前言&quot;&gt;&lt;/a&gt;一、 前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;最近要开始干活了～老板要求边做边写开发文档，啊啊啊啊，就把这一系列的文档发在博客里面吧，需要的时候再来拿，还能凑几篇博客。这是第一篇，关于Nginx+php+MySQL环境搭建的，很简单网上很多～～～&lt;br&gt;
    
    </summary>
    
      <category term="Website" scheme="http://heany.github.io/categories/Website/"/>
    
    
      <category term="Nginx-php-MySQL" scheme="http://heany.github.io/tags/Nginx-php-MySQL/"/>
    
  </entry>
  
  <entry>
    <title>TF-IDF理解</title>
    <link href="http://heany.github.io/2018/05/14/TF-IDF%E7%90%86%E8%A7%A3/"/>
    <id>http://heany.github.io/2018/05/14/TF-IDF理解/</id>
    <published>2018-05-14T07:38:47.000Z</published>
    <updated>2019-01-26T14:47:30.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h2><p>&emsp;最近在看关于特征抽取的论文，希望能从中找到一些方法来做数据抄袭检测，看到了一篇关于中文文本复制检测的文章，里面用到了TF-IDF算法，查找了些资料，把它整理了一下～～<br><a id="more"></a></p><h2 id="二、-TF-IDF的理解"><a href="#二、-TF-IDF的理解" class="headerlink" title="二、 TF-IDF的理解"></a>二、 TF-IDF的理解</h2><p>&emsp;TF-IDF（term frequency–inverse document frequency）是一种用于资讯检索与资讯探勘的常用加权技术, TFIDF的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。TFIDF实际上是：TF * IDF，TF词频(Term Frequency)，IDF反文档频率(Inverse Document Frequency)。TF表示词条在文档d中出现的频率。IDF的主要思想是：如果包含词条t的文档越少，也就是n越小，IDF越大，则说明词条t具有很好的类别区分能力。如果某一类文档C中包含词条t的文档数为m，而其它类包含t的文档总数为k，显然所有包含t的文档数n=m + k，当m大的时候，n也大，按照IDF公式得到的IDF的值会小，就说明该词条t类别区分能力不强。但是实际上，如果一个词条在一个类的文档中频繁出现，则说明该词条能够很好代表这个类的文本的特征，这样的词条应该给它们赋予较高的权重，并选来作为该类文本的特征词以区别与其它类文档。这就是IDF的不足之处。</p><p><strong>TF公式：</strong></p><p><img src="https://wx3.sinaimg.cn/mw690/e0db46edgy1fraxzqql9wj20au03i747.jpg" align="center"></p><p>以上式子中$n_i,j$是该词在文件$d_j$中出现的次数，而分母则是在文件$d_j$中所有字词的出现次数之和。</p><p><strong>IDF公式：</strong></p><p><img src="https://wx2.sinaimg.cn/mw690/e0db46edgy1fraxzqr8tdj210p0a20u7.jpg" align="center"></p><h2 id="三、-简单案例理解"><a href="#三、-简单案例理解" class="headerlink" title="三、 简单案例理解"></a>三、 简单案例理解</h2><p>假如一篇文件的总词语数是100个，而词语“母牛”出现了3次，那么“母牛”一词在该文件中的词频就是3/100=0.03。一个计算文件频率 (DF) 的方法是测定有多少份文件出现过“母牛”一词，然后除以文件集里包含的文件总数。所以，如果“母牛”一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是 lg(10,000,000 / 1,000)=4。最后的TF-IDF的分数为0.03 * 4=0.12。</p><h2 id="四、-结束语"><a href="#四、-结束语" class="headerlink" title="四、 结束语"></a>四、 结束语</h2><p><code>markdown</code>写公式没有加载出来，不知道咋回事～可能模板的锅。</p><p><code>LaTex</code>写公式真方便啊～～～</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、-前言&quot;&gt;&lt;a href=&quot;#一、-前言&quot; class=&quot;headerlink&quot; title=&quot;一、 前言&quot;&gt;&lt;/a&gt;一、 前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;最近在看关于特征抽取的论文，希望能从中找到一些方法来做数据抄袭检测，看到了一篇关于中文文本复制检测的文章，里面用到了TF-IDF算法，查找了些资料，把它整理了一下～～&lt;br&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://heany.github.io/categories/Machine-Learning/"/>
    
    
      <category term="TF-IDF-Algorithm" scheme="http://heany.github.io/tags/TF-IDF-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>删除Github.com上repository中的某个文件夹</title>
    <link href="http://heany.github.io/2018/04/18/%E5%88%A0%E9%99%A4Github-com%E4%B8%8Arepository%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    <id>http://heany.github.io/2018/04/18/删除Github-com上repository中的某个文件夹/</id>
    <published>2018-04-18T11:28:46.000Z</published>
    <updated>2019-01-26T14:47:30.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h2><p>&emsp;最近上传项目的时候，粗心大意～忘记将一些需要忽略的文件夹加进<code>.gitignore</code>文件中！！！导致把项目中所有文件都上传到<code>github.com</code>上去了，其中有一些文件我并不想上传上去。<a id="more"></a>所以呢？我现在想要把一个文件夹（例如<code>bigData</code>）在<code>github</code>删除，但是又不想把本地的<code>bigData</code>文件夹删掉～但是！<code>github</code>上面只能删除文件（如下图所示），并不支持删除文件夹。</p><p><img src="https://wx1.sinaimg.cn/mw690/e0db46edgy1fqh1t1v3g5j20rk08lmyh.jpg" align="center"></p><h2 id="二、采用git指令来进行删除操作"><a href="#二、采用git指令来进行删除操作" class="headerlink" title="二、采用git指令来进行删除操作"></a>二、采用<code>git</code>指令来进行删除操作</h2><p><strong>代码如下所示：（以删除bigData文件夹为例）</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先切换到本地工作目录，也就是与github上对应的那个目录。</span></span><br><span class="line"><span class="built_in">cd</span> dir/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后执行下面的git命令</span></span><br><span class="line">git rm -r --cached bigData    <span class="comment"># --cached不会把本地的bigData删除</span></span><br><span class="line">git commit -m <span class="string">"delete bigData dir"</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、-前言&quot;&gt;&lt;a href=&quot;#一、-前言&quot; class=&quot;headerlink&quot; title=&quot;一、 前言&quot;&gt;&lt;/a&gt;一、 前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;最近上传项目的时候，粗心大意～忘记将一些需要忽略的文件夹加进&lt;code&gt;.gitignore&lt;/code&gt;文件中！！！导致把项目中所有文件都上传到&lt;code&gt;github.com&lt;/code&gt;上去了，其中有一些文件我并不想上传上去。
    
    </summary>
    
      <category term="Github" scheme="http://heany.github.io/categories/Github/"/>
    
    
      <category term="git" scheme="http://heany.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Docker技术学习</title>
    <link href="http://heany.github.io/2018/04/16/Docker%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    <id>http://heany.github.io/2018/04/16/Docker技术学习/</id>
    <published>2018-04-16T07:20:03.000Z</published>
    <updated>2019-01-26T14:47:30.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h2><p>我们都知道软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p><p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p><p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。虽然用户可以通过虚拟机还原软件的原始环境，但是虚拟机却有很多缺点，资源占用较多，拖慢计算机的运行速度，<br>冗余步骤多;启动很慢等。结构对比如下图所示：</p><p><img src="https://wx3.sinaimg.cn/mw1024/e0db46edgy1fqek1ao1k6j20kt0e8dhv.jpg" align="center"></p><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><p>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。由于<strong>容器</strong>是进程级别的，相比虚拟机有很多优势。例如：启动很快，资源占用少;体积很小。容器就像是轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销比虚拟机要小得多。</p><h2 id="二、-Docker是什么？"><a href="#二、-Docker是什么？" class="headerlink" title="二、 Docker是什么？"></a>二、 Docker是什么？</h2><p><strong>Docker属于Linux容器的一种封装，提供简单易用的容器使用接口</strong>。它是目前最流行的 Linux 容器解决方案。</p><p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p><p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h2 id="三、-基本概念"><a href="#三、-基本概念" class="headerlink" title="三、 基本概念"></a>三、 基本概念</h2><p>Docker包括三个基本概念：</p><ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）</li></ul><p>理解了这三个概念，也就理解了Docker的整个生命周期。</p><h3 id="3-1、-Docker镜像（Image）"><a href="#3-1、-Docker镜像（Image）" class="headerlink" title="3.1、 Docker镜像（Image）"></a>3.1、 <code>Docker</code>镜像（Image）</h3><p>我们都知道,操作系统分为内核和用户空间。对于Linux而言,内核启动后,会挂载root文件系统为其提供用户空间支持。而 Docker 镜像(Image),就相当于是一个文件系统。比如官方镜像<code>ubuntu:16.04</code>就包含了完整的一套<code>Ubuntu 16.04</code>最小系统的<code>root</code>文件系统。</p><p>Docker 镜像是一个特殊的文件系统,除了提供容器运行时所需的程序、库、资源、配置等文件外,还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。镜像不包含任何动态数据,其内容在构建之后也不会被改变。</p><h4 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h4><p>因为镜像包含操作系统完整的<code>root</code>文件系统,其体积往往是庞大的,因此在<code>Docker</code>设计时,就充分利用<code>Union FS</code>的技术,将其设计为分层存储的架构。所以严格来说,镜像并非是像一个<code>ISO</code>那样的打包文件,镜像只是一个虚拟的概念,其实际体现并非由一个文件组成,而是由一组文件系统组成,或者说,由多层文件系统联合组成。</p><p>镜像构建时,会一层层构建,前一层是后一层的基础。每一层构建完就不会再发生改变,后一层上的任何改变只发生在自己这一层。比如,删除前一层文件的操作,实际不是真的删除前一层的文件,而是仅在当前层标记为该文件已删除。在最终容器运行的时候,虽然不会看到这个文件,但是实际上该文件会一直跟随镜像。因此,在构建镜像的时候,需要额外小心,每一层尽量只包含该层需要添加的东西,任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层,然后进一步添加新的层,以定制自己所需的内容,构建新的镜像。</p><h3 id="3-2、-Docker容器"><a href="#3-2、-Docker容器" class="headerlink" title="3.2、 Docker容器"></a>3.2、 <code>Docker</code>容器</h3><p>镜像(Image)和容器(Container)的关系,就像是面向对象程序设计中的类和实例一样,镜像是静态的定义,容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程,但与直接在宿主执行的进程不同,容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的<code>root</code>文件系统、自己的网络配置、自己的进程空间,甚至自己的用户<code>ID</code>空间。容器内的进程是运行在一个隔离的环境里,使用起来,就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性,很多人初学<code>Docker</code>时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储,容器也是如此。每一个容器运行时,是以镜像为基础层,在其上创建一个当前容器的存储层,我们可以称这个<strong>为容器运行时读写而准备的存储层为容器存储层。</strong></p><p>容器存储层的生存周期和容器一样,容器消亡时,容器存储层也随之消亡。因此,任何保存<br>于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求,容器不应该向其存储层内写入任何数据,容器存储层要保持无<br>状态化。所有的文件写入操作,都应该使用数据卷(Volume)、或者绑定宿主目录,在这些位置的读写会跳过容器存储层,直接对宿主(或网络存储)发生读写,其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器,容器消亡,数据卷不会消亡。因此,使用数据卷后,容器删除或者重新运行之后,数据却不会丢失。</p><h3 id="3-3、-Docker仓库（Registry）"><a href="#3-3、-Docker仓库（Registry）" class="headerlink" title="3.3、 Docker仓库（Registry）"></a>3.3、 <code>Docker</code>仓库（Registry）</h3><p>镜像构建完成后,可以很容易的在当前宿主机上运行,但是,如果需要在其它服务器上使用这个镜像,我们就需要一个集中的存储、分发镜像的服务,Docker Registry 就是这样的服务。</p><p>一个<code>Docker Registry</code>中可以包含多个仓库(<code>Repository</code>);每个仓库可以包含多个标签(<code>Tag</code>);每个标签对应一个镜像。</p><p>通常,一个仓库会包含同一个软件不同版本的镜像,而标签就常用于对应该软件的各个版本。我们可以通过<br><code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签,将以<code>latest</code>作为默认标签。</p><p>以<code>Ubuntu</code>镜像 为例,<code>ubuntu</code>是仓库的名字,其内包含有不同的版本标签,如,<code>14.04</code>,<code>16.04</code>。我们可以通过<code>ubuntu:14.04</code>,或者<code>ubuntu:16.04</code>来具体指定所需哪个版本的镜像。如果忽略了标签,比如<code>ubuntu</code>,那将视为<code>ubuntu:latest</code>。</p><p>仓库名经常以两段式路径形式出现,比如<code>jwilder/nginx-proxy</code>,前者往往意味着<code>Docker Registry</code>多用户环境下的用户名,后者则往往是对应的软件名。但这并非绝对,取决于所使用的具体<code>Docker Registry</code>的软件或服务。</p><h4 id="3-3-1、-Docker-Registry-公开服务"><a href="#3-3-1、-Docker-Registry-公开服务" class="headerlink" title="3.3.1、 Docker Registry 公开服务"></a>3.3.1、 Docker Registry 公开服务</h4><p><code>Docker Registry</code>公开服务是开放给用户使用、允许用户管理镜像的<code>Registry</code>服务。一般这类<br>公开服务允许用户免费上传、下载公开的镜像,并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 <code>Registry</code>公开服务是官方的<code>Docker Hub</code>,这也是默认的<code>Registry</code>,并拥有大量的高质量的官方镜像。除此以外,还有<code>CoreOS</code>的<code>Quay.io</code>,<code>CoreOS</code>相关的镜像存储在这里;Google的<code>Google Container Registry</code>,<code>Kubernetes</code>的镜像使用的就是这个服务。</p><p>由于某些原因,在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对<code>Docker Hub</code>的镜像服务(<code>Registry Mirror</code>),这些镜像服务被称为加速器。常见的有阿里云加速器、<code>DaoCloud</code>加速器 等。使用加速器会直接从国内的地址下载<code>Docker Hub</code>的镜像,比直接从<code>Docker Hub</code>下载速度会提高很多。</p><p>国内也有一些云服务商提供类似于<code>Docker Hub</code>的公开服务。比如时速云镜像仓库、网易云镜像服务、<code>DaoCloud</code>像市场、阿里云镜像库 等。</p><h4 id="3-3-2、-私有-Docker-Registry"><a href="#3-3-2、-私有-Docker-Registry" class="headerlink" title="3.3.2、 私有 Docker Registry"></a>3.3.2、 私有 Docker Registry</h4><p>除了使用公开服务外,用户还可以在本地搭建私有<code>Docker Registry</code>。<code>Docker</code>官方提供了<code>Docker Registry</code>镜像,可以直接使用做为私有<code>Registry</code>服务。</p><p>开源的<code>Docker Registry</code>镜像只提供了<code>Docker Registry API</code>的服务端实现,足以支持<code>docker</code>命令,不影响使用。但不包含图形界面,以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本<code>Docker Trusted Registry</code>中,提供了这些高级功能。</p><p>除了官方的<code>Docker Registry</code>外,还有第三方软件实现了<code>Docker Registry API</code>,甚至提供了用<br>户界面以及一些高级功能。比如,<code>VMWare Harbor</code>和<code>Sonatype Nexus</code>。</p><h2 id="四、-Docker的安装"><a href="#四、-Docker的安装" class="headerlink" title="四、 Docker的安装"></a>四、 <code>Docker</code>的安装</h2><p><code>Docker</code>是一个开源的商业产品。<code>Docker CE</code>（社区版）安装参考官方文档。</p><p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Ubuntu</a></p><p><strong>使用了国内源</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">update</span></span><br><span class="line"></span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> \</span><br><span class="line">apt-transport-https \</span><br><span class="line">ca-certificates \</span><br><span class="line">curl \</span><br><span class="line">software-properties-common</span><br><span class="line"></span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-<span class="keyword">key</span> <span class="keyword">add</span></span><br><span class="line"></span><br><span class="line"> sudo <span class="keyword">add</span>-apt-repository \</span><br><span class="line"><span class="string">"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">$(lsb_release -cs) \</span></span><br><span class="line"><span class="string">stable"</span></span><br><span class="line"></span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">sudo systemctl <span class="keyword">enable</span> docker</span><br><span class="line">sudo systemctl <span class="keyword">start</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立docker用户组</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $<span class="keyword">USER</span></span><br></pre></td></tr></table></figure></p><p>安装完成后，需配置国内镜像加速,<a href="https://github.com/yeasy/docker_practice/blob/master/install/mirror.md" target="_blank" rel="noopener">参考这篇文章</a>：</p><blockquote><p> 在<code>/etc/docker/daemon.json</code>中写入如下内容（如果文件不存在请新建该文件）</p></blockquote><pre><code>{    &quot;registry-mirrors&quot;: [        &quot;https://registry.docker-cn.com&quot;    ]}</code></pre><p>之后重新启动docker服务：</p><pre><code>sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p>检查加速器是否生效：</p><pre><code>sudo docker info# 看到如下内容说明配置成功 Registry Mirrors:    https://registry.docker-cn.com/</code></pre><p><strong>测试Docker是否安装正确</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line">Unable <span class="keyword">to</span> <span class="keyword">find</span> image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">lates<span class="variable">t:</span> Pulling from library/hello-world</span><br><span class="line"><span class="number">9</span>bb5a5d4561<span class="variable">a:</span> Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77</span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears <span class="keyword">to</span> <span class="keyword">be</span> working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following step<span class="variable">s:</span></span><br><span class="line"> <span class="number">1</span>. The Docker client contacted the Docker daemon.</span><br><span class="line">          ...........</span><br></pre></td></tr></table></figure></p><h2 id="五、-Image文件"><a href="#五、-Image文件" class="headerlink" title="五、 Image文件"></a>五、 <code>Image</code>文件</h2><p><strong>Docker把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个image文件往往通过继承另一个image文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的image。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机所有的<span class="keyword">image</span>文件</span><br><span class="line">docker <span class="keyword">image</span> <span class="keyword">ls</span></span><br><span class="line"></span><br><span class="line"># 删除<span class="keyword">image</span>文件</span><br><span class="line">docker <span class="keyword">image</span> rm [imageName]</span><br></pre></td></tr></table></figure></p><p><strong>image 文件是通用的，一台机器的image文件拷贝到另一台机器，照样可以使用。</strong>一般来说，为了节省时间，我们应该尽量使用别人制作好的image文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库<code>Docker Hub</code> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><p>将image文件从仓库抓取到本地。</p><pre><code>docker image pull library/hello-world# docker image pull 是抓取image的命令。library/hello-world是image文件在仓库里面的位置，其中library是image文件所在的组，hello-world是image的名字。</code></pre><p>由于Docker官方提供的image文件，都放在library组里面，所以它是默认组，可以省略，因此，上面的命令可以写成下面这样：</p><pre><code>docker image pull hello-world</code></pre><p>抓取成功后，就可以在本机看到这个image文件了</p><pre><code>docker image ls</code></pre><p>运行<code>image</code>文件命令如下：</p><pre><code>docker container run hello-world或者docker run hello-world</code></pre><blockquote><p> <code>docker container run</code>或者<code>docker run</code>命令会从image文件，生成一个正在运行的容器实例。如果本地没有找到image文件，docker就会从仓库自动抓取image文件，因此，前面的<code>docker image pull</code>命令不是必需的步骤。</p></blockquote><p><b style="color: red">注意:</b>有些容器不会自动终止，必须使用<code>docker container kill</code>命令手动终止。<code>docker container kill [containID]</code></p><h2 id="六、-容器文件"><a href="#六、-容器文件" class="headerlink" title="六、 容器文件"></a>六、 容器文件</h2><p><strong> <code>image</code>文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件：image文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><pre><code># 列出本机正在运行的容器docker container ls## 列出本机所有容器，包括终止运行的容器docker container ls -all## 运行终止的容器文件，依然会占据硬盘空间，可以使用以下命令删除。docker container rm [containerID]</code></pre><p>学会使用image文件以后，接下来的问题就是，如何可以生成image文件？如果你要推广自己的软件，势必要自己制作image 文件。这就需要用到<code>Dockerfile</code>文件。它是一个文本文件，用来配置image。Docker根据该文件生成二进制的 image 文件。下一章将通过一个实例来介绍如何编写<code>Dockfile</code>文件。</p><h2 id="七、-实例：制作自己的Docker容器"><a href="#七、-实例：制作自己的Docker容器" class="headerlink" title="七、 实例：制作自己的Docker容器"></a>七、 实例：制作自己的Docker容器</h2><p>下面我以<a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="noopener">koa-demos</a>项目为例，介绍怎么写<code>Dockerfile</code>文件，实现让用户在<code>Docker</code>容器里面运行<code>Koa</code>框架。<br>作为准备工作，请先<a href="https://github.com/ruanyf/koa-demos/archive/master.zip" target="_blank" rel="noopener">下载源码</a>，或者采用下面方式下载。</p><pre><code>git clone https://github.com/ruanyf/koa-demos.gitcd koa-demos</code></pre><h3 id="7-1、-编写Dockerfile文件"><a href="#7-1、-编写Dockerfile文件" class="headerlink" title="7.1、 编写Dockerfile文件"></a>7.1、 编写<code>Dockerfile</code>文件</h3><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>,写入下面的内容，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.git</span></span><br><span class="line"><span class="selector-tag">node_modules</span></span><br><span class="line"><span class="selector-tag">npm-debug</span><span class="selector-class">.log</span></span><br></pre></td></tr></table></figure><p>上面的代码表示，这三个路径要排除，不要打包进入image文件，如果没有要排除的路径，可以不写。</p><p>然后，在项目的根目录下，新建一个文本文件Dockerfile。写入下面的内容。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="bash">WORKDIR /app</span></span><br><span class="line"><span class="bash">RUN npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="bash">EXPOSE 3000</span></span><br></pre></td></tr></table></figure></p><p>上面五行代码，含义如下。</p><ul><li><code>FROM node:8.4</code>：该image文件继承官方的<code>node image</code>，冒号表示标签，这里标签是8.4，即8.4版本的 node。</li><li>COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</li><li>WORKDIR /app：指定接下来的工作路径为/app。</li><li>RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li>EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul><h3 id="7-2、-创建image文件"><a href="#7-2、-创建image文件" class="headerlink" title="7.2、 创建image文件"></a>7.2、 创建image文件</h3><p>有了Dockerfile文件以后，就可以使用<code>docker image build</code>命令创建image文件了。</p><pre><code>docker image build -t koa-demo .# 或者docker image build -t koa-demo:0.0.1 .</code></pre><p>在上面的代码中，<code>-t</code>参数用来指定image文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latet</code>。最后的那个点<code>.</code>表示<code>dockfile</code>文件所在的路径，上例是当前路径，所以是一个点。如果运行成功就可以看到新生成的image文件<code>koa-demo</code>了。</p><pre><code># 查看image文件 docker image ls</code></pre><h3 id="7-3、-生成容器"><a href="#7-3、-生成容器" class="headerlink" title="7.3、 生成容器"></a>7.3、 生成容器</h3><p><code>docker container run</code>命令会从<code>image</code>文件生成容器。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">run</span> -p <span class="number">8000</span>:<span class="number">3000</span> -<span class="keyword">it</span> koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker container <span class="built_in">run</span> -p <span class="number">8000</span>:<span class="number">3000</span> -<span class="keyword">it</span> kao-demo:<span class="number">0.0</span><span class="number">.1</span> /bin/bash</span><br></pre></td></tr></table></figure></p><p>上面命令的参数含义如下：</p><ul><li>-p参数：容器的3000端口映射到本机的8000端口</li><li>-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li>koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li>/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul><p>如果一切正常，运行上面的命令后，就会返回一个命令行提示符。</p><pre><code>root@805724fbb49b:/app# </code></pre><p>这就表示你已经在容器里面了，返回的提示符就是容器内部的<code>Shell</code>提示符。执行下面的命令。</p><pre><code>root@805724fbb49b:/app# node demos/01.js</code></pre><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问<code>http://127.0.0.1:8000</code>，网页显示”Not Found”，这是因为这个 demo 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><pre><code>#在本机的另一个终端窗口，查处容器的IDdocker container ls## 停止指定的容器运行docker container kill [containerID]</code></pre><p>容器停止运行后不会消失，用下面的命令删除容器文件。<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查处容器的ID</span></span><br><span class="line"><span class="attribute">docker</span> container ls -<span class="literal">all</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定容器文件</span></span><br><span class="line"><span class="attribute">docker</span> container rm<span class="meta"> [containerID]</span></span><br></pre></td></tr></table></figure></p><blockquote><p> 也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。<br> <code>docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</code></p></blockquote><h3 id="7-4、-CMD命令"><a href="#7-4、-CMD命令" class="headerlink" title="7.4、 CMD命令"></a>7.4、 <code>CMD</code>命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在<code>Dockerfile</code>里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="bash">WORKDIR /app</span></span><br><span class="line"><span class="bash">RUN npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="bash">EXPOSE 3000</span></span><br><span class="line"><span class="bash">CMD node demos/01.js</span></span><br></pre></td></tr></table></figure></p><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在<code>image</code>文件的构建阶段执行，执行结果都会打包进入<code>image</code>文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个<code>Dockerfile</code>可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><pre><code>docker container run --rm -p 8000:3000 -it koa-demo</code></pre><h3 id="7-5、-发布image文件"><a href="#7-5、-发布image文件" class="headerlink" title="7.5、 发布image文件"></a>7.5、 发布<code>image</code>文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。</p><pre><code>docker login</code></pre><p>然后，为本地的image标注用户名和版本。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="keyword">tag</span> <span class="title">[imageName</span>] [username]/[repository]:[<span class="keyword">tag</span>]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">docker image <span class="keyword">tag</span> <span class="title">koa-demos</span>:<span class="number">0.0</span>.<span class="number">1</span> heany/koa-demos:<span class="number">0.0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>也可以不用标注用户名，重新构建一下image文件。</p><pre><code>docker image build -t [username]/[repository]:[tag]</code></pre><p>最后，发布image文件。</p><pre><code>docker image push [username]/[repository]:[tag]</code></pre><p>发布成功后，登录hub.docker.com，就可以看到已经发布的image文件。<b style="color: red">目前国内链接<code>hub.docker.com</code>非常慢，push经常超时，可以使用国内的<code>daocloud</code>。</b></p><h2 id="八、-其他有用的命令"><a href="#八、-其他有用的命令" class="headerlink" title="八、 其他有用的命令"></a>八、 其他有用的命令</h2><p><code>docker</code>的主要用法就是上面这些此外还有几个命令，也非常有用。</p><h3 id="8-1、-docker-container-start"><a href="#8-1、-docker-container-start" class="headerlink" title="8.1、 docker container start"></a>8.1、 <code>docker container start</code></h3><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p><pre><code>docker container start [containerID]</code></pre><h3 id="8-2、-docker-container-stop"><a href="#8-2、-docker-container-stop" class="headerlink" title="8.2、 docker container stop"></a>8.2、 <code>docker container stop</code></h3><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出<code>SIGKILL</code> 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出<code>SIGTERM</code>信号，然后过一段时间再发出 SIGKILL 信号。</p><pre><code>bash container stop [containerID]</code></pre><p>这两个信号的差别是，应用程序收到<code>SIGTERM</code>信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到<code>SIGKILL</code>信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><h3 id="8-3、-docker-container-logs"><a href="#8-3、-docker-container-logs" class="headerlink" title="8.3、 docker container logs"></a>8.3、 <code>docker container logs</code></h3><p><code>docker container logs</code>命令用来查看<code>docker</code>容器的输出，即容器里面<code>Shell</code>的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。</p><pre><code>docker container logs [containerID]</code></pre><h3 id="8-4、-docker-container-exec"><a href="#8-4、-docker-container-exec" class="headerlink" title="8.4、 docker container exec"></a>8.4、 <code>docker container exec</code></h3><p><code>docker container exec</code>命令用于进入一个正在运行的<code>docker</code>容器。如果<code>docker run</code>命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的<code>Shell</code>执行命令了。</p><pre><code>docker container exec -it [containerID] /bin/bash</code></pre><h3 id="8-5、-docker-container-cp"><a href="#8-5、-docker-container-cp" class="headerlink" title="8.5、 docker container cp"></a>8.5、 <code>docker container cp</code></h3><p><code>docker container cp</code>命令用于从正在运行的<code>Docker</code>容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p><pre><code>docker container cp [containID]:[/path/to/file]</code></pre><h2 id="九、-结束语"><a href="#九、-结束语" class="headerlink" title="九、 结束语"></a>九、 结束语</h2><p>&emsp;转载于<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">阮一峰的网络日志-Docker入门教程</a><br>&emsp;参考了<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">Docker技术入门与实战</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、-前言&quot;&gt;&lt;a href=&quot;#一、-前言&quot; class=&quot;headerlink&quot; title=&quot;一、 前言&quot;&gt;&lt;/a&gt;一、 前言&lt;/h2&gt;&lt;p&gt;我们都知道软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来
      
    
    </summary>
    
      <category term="分布式与大数据" scheme="http://heany.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Docker" scheme="http://heany.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>sublime text 3 最新的注册码</title>
    <link href="http://heany.github.io/2018/04/09/sublime-text-3-%E6%9C%80%E6%96%B0%E7%9A%84%E6%B3%A8%E5%86%8C%E7%A0%81/"/>
    <id>http://heany.github.io/2018/04/09/sublime-text-3-最新的注册码/</id>
    <published>2018-04-09T12:46:12.000Z</published>
    <updated>2019-01-26T14:47:30.579Z</updated>
    
    <content type="html"><![CDATA[<p>最新可用的sublime Text 3注册码<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">—– BEGIN LICENSE —– </span><br><span class="line">TwitterInc </span><br><span class="line"><span class="number">200</span> User License </span><br><span class="line">EA7E<span class="number">-890007</span> </span><br><span class="line"><span class="number">1</span>D77F72E <span class="number">390</span>CDD93 <span class="number">4</span>DCBA022 FAF60790 </span><br><span class="line"><span class="number">61</span>AA12C0 A37081C5 D0316412 <span class="number">4584</span>D136 </span><br><span class="line"><span class="number">94</span>D7F7D4 <span class="number">95</span>BC8C1C <span class="number">527</span>DA828 <span class="number">560</span>BB037 </span><br><span class="line">D1EDDD8C AE7B379F <span class="number">50</span>C9D69D B35179EF </span><br><span class="line"><span class="number">2</span>FE898C4 <span class="number">8E4277</span>A8 <span class="number">555</span>CE714 E1FB0E43 </span><br><span class="line">D5D52613 C3D12E98 BC49967F <span class="number">7652</span>EED2 </span><br><span class="line"><span class="number">9</span>D2D2E61 <span class="number">67610860</span> <span class="number">6</span>D338B72 <span class="number">5</span>CF95C69 </span><br><span class="line">E36B85CC <span class="number">84991</span>F19 <span class="number">7575</span>D828 <span class="number">470</span>A92AB </span><br><span class="line">—— END LICENSE ——</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最新可用的sublime Text 3注册码&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
      <category term="常用工具" scheme="http://heany.github.io/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="sublime-text-3 注册码" scheme="http://heany.github.io/tags/sublime-text-3-%E6%B3%A8%E5%86%8C%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 17.10配置Hadoop+Spark环境</title>
    <link href="http://heany.github.io/2018/04/08/Ubuntu-17-10%E9%85%8D%E7%BD%AEHadoop-Spark%E7%8E%AF%E5%A2%83/"/>
    <id>http://heany.github.io/2018/04/08/Ubuntu-17-10配置Hadoop-Spark环境/</id>
    <published>2018-04-08T06:39:34.000Z</published>
    <updated>2019-01-26T14:47:30.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&nbsp;&nbsp;最近导师带的项目是与大数据相关，感觉这几年大数据技术还挺火的，就想着也去学一下，丰富自己的技能栈。本文主要讲的是hadoop+spark的环境搭建,然后使用自带的examples测试环境，这里不涉及原理介绍。<a id="more"></a></p><h2 id="二、Hadoop的三种运行模式介绍"><a href="#二、Hadoop的三种运行模式介绍" class="headerlink" title="二、Hadoop的三种运行模式介绍"></a>二、Hadoop的三种运行模式介绍</h2><h3 id="2-1、-单机模式也叫独立模式（Local或Standalone-Mode）"><a href="#2-1、-单机模式也叫独立模式（Local或Standalone-Mode）" class="headerlink" title="2.1、 单机模式也叫独立模式（Local或Standalone Mode）"></a>2.1、 单机模式也叫独立模式（Local或Standalone Mode）</h3><ul><li>默认情况下，Hadoop即处于该模式，用于开发和调式。</li><li>不对配置文件进行修改。</li><li>使用本地文件系统，而不是分布式文件系统。</li><li>Hadoop不会启动NameNode、DataNode、JobTracker、TaskTracker等守护进程，Map()和Reduce()任务作为同一个进程的不同部分来执行的。</li><li>用于对MapReduce程序的逻辑进行调试，确保程序的正确。</li></ul><h3 id="2-2、-伪分布式模式（Pseudo-Distrubuted-Mode）"><a href="#2-2、-伪分布式模式（Pseudo-Distrubuted-Mode）" class="headerlink" title="2.2、 伪分布式模式（Pseudo-Distrubuted Mode）"></a>2.2、 伪分布式模式（Pseudo-Distrubuted Mode）</h3><ul><li>Hadoop的守护进程运行在本机机器上，模拟一个小规模的集群</li><li>在一台主机上模拟多主机。</li><li>Hadoop启动NameNode、DataNode、JobTracker、TaskTracker这些守护进程都在同一台机器上运行，是相互独立的Java进程。</li><li>在这种模式下，Hadoop使用的是分布式文件系统，各个作业也是由JobTraker服务，来管理的独立进程。在单机模式之上增加了代码调试功能，允许检查内存使用情况，HDFS输入输出，以及其他的守护进程交互。类似于完全分布式模式，因此，这种模式常用来开发测试Hadoop程序的执行是否正确。</li><li>修改3个配置文件：core-site.xml（Hadoop集群的特性，作用于全部进程及客户端）、hdfs-site.xml（配置HDFS集群的工作属性）、mapred-site.xml（配置MapReduce集群的属性）</li><li>格式化文件系统</li></ul><h3 id="2-3、-全分布式集群模式（Full-Distributed-Mode）"><a href="#2-3、-全分布式集群模式（Full-Distributed-Mode）" class="headerlink" title="2.3、 全分布式集群模式（Full-Distributed Mode）"></a>2.3、 全分布式集群模式（Full-Distributed Mode）</h3><ul><li>Hadoop的守护进程运行在一个集群上　</li><li>Hadoop的守护进程运行在由多台主机搭建的集群上，是真正的生产环境。</li><li>在所有的主机上安装JDK和Hadoop，组成相互连通的网络。</li><li>在主机间设置SSH免密码登录，把各从节点生成的公钥添加到主节点的信任列表。</li><li>修改3个配置文件：core-site.xml、hdfs-site.xml、mapred-site.xml，指定NameNode和JobTraker的位置和端口，设置文件的副本等参数</li><li>格式化文件系统。</li></ul><h2 id="三、搭建伪分布式集群的前提条件"><a href="#三、搭建伪分布式集群的前提条件" class="headerlink" title="三、搭建伪分布式集群的前提条件"></a>三、搭建伪分布式集群的前提条件</h2><h3 id="3-1、-实验环境"><a href="#3-1、-实验环境" class="headerlink" title="3.1、 实验环境"></a>3.1、 实验环境</h3><ul><li style="list-style: none"><input type="checkbox" checked> <strong>ubuntu 17.10-x64</strong></li><li style="list-style: none"><input type="checkbox" checked> <strong>jdk_1.8.0_162</strong></li><li style="list-style: none"><input type="checkbox" checked> <strong>Hadoop-3.0.0</strong></li><li style="list-style: none"><input type="checkbox" checked> <strong>Spark-2.3.0</strong></li></ul><h3 id="3-2、-安装JDK，并配置环境变量"><a href="#3-2、-安装JDK，并配置环境变量" class="headerlink" title="3.2、 安装JDK，并配置环境变量"></a>3.2、 安装JDK，并配置环境变量</h3><p>&nbsp;&nbsp;首先去官网下载对应系统版本的jdk,然后解压到<code>opt</code>目录下，命令如下：</p><blockquote><pre><code>sudo tar -zxvf jdk-8u162-linux-x64.tar.gz -C /opt</code></pre></blockquote><p>然后切换到<code>/opt</code>目录下，修改jdk的文件夹命名</p><blockquote><pre><code>mv jdk-8u162-linux-x64 ./jdk</code></pre></blockquote><p>最后，配置环境变量，</p><blockquote><pre><code>vim /etc/profile</code></pre></blockquote><p>在配置文件中加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/jdk</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p>使配置文件生效，执行下面的命令：</p><pre><code>source /etc/profile</code></pre><p>最后查看是否安装成功</p><pre><code>java -version</code></pre><h3 id="3-3、-安装Scala"><a href="#3-3、-安装Scala" class="headerlink" title="3.3、 安装Scala"></a>3.3、 安装Scala</h3><ul><li>官网下载scala(scala-2.12.4.tgz)</li><li><p>解压下载scala包</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xzvf scala<span class="number">-2.12</span><span class="number">.4</span>.tgz -C /opt/</span><br><span class="line"># 修改文件名：</span><br><span class="line">sudo mv scala<span class="number">-2.12</span><span class="number">.4</span> ./scala</span><br></pre></td></tr></table></figure></li><li><p>添加环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="comment"># 在后面添加下面内容</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">SCALA_HOME</span>=/opt/scala</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$SCALA_HOME</span>/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>使配置生效并测试</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line"><span class="comment"># 测试是否安装成功</span></span><br><span class="line">scala -version  # 输出scala版本号</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4、-安装ssh并设置免密登录"><a href="#3-4、-安装ssh并设置免密登录" class="headerlink" title="3.4、 安装ssh并设置免密登录"></a>3.4、 安装ssh并设置免密登录</h3><ul><li><p>安装ssh。如果已安装则跳过这一步。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>配置ssh无密登录</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa <span class="comment"># 然后一直回车</span></span><br><span class="line">cat ~<span class="regexp">/.ssh/id</span>_rsa.pub <span class="meta">&gt;&gt; </span>~<span class="regexp">/.ssh/authorized</span>_keys</span><br></pre></td></tr></table></figure></li><li><p>测试ssh无密登录</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh</span> localhost</span><br><span class="line"><span class="comment"># 如果不提示输入密码则配置成功</span></span><br></pre></td></tr></table></figure></li></ul><p>[TOC]</p><h2 id="四、搭建伪分布式集群"><a href="#四、搭建伪分布式集群" class="headerlink" title="四、搭建伪分布式集群"></a>四、搭建伪分布式集群</h2><h3 id="4-1、-hadoop下载安装"><a href="#4-1、-hadoop下载安装" class="headerlink" title="4.1、 hadoop下载安装"></a>4.1、 hadoop下载安装</h3><ul><li>下载Hadoop(笔者下载的是hadoop-3.0.0.tar.gz)</li><li><p>解压并重命名</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">sudo tar -xzvf hadoop-3.0.0.tar.gz -C <span class="string">/opt/</span></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">/opt</span></span><br><span class="line">sudo hadoop-3.0.0 hadoop</span><br></pre></td></tr></table></figure></li><li><p>修改文件权限</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/opt</span></span><br><span class="line">sudo chown -R yourname<span class="function">:yourname</span> hadoop  </span><br><span class="line"><span class="comment"># yourname替换成你的用户名  -R表示逐级往下授权</span></span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="comment"># 在最后添加下面代码</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">HADOOP_HOME</span>=/opt/hadoop</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">HADOOP_COMMON_LIB_NATIVE_DIR</span>=<span class="variable">$HADOOP_HOME</span>/lib/native</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">HADOOP_OPTS</span>=<span class="string">"-Djava.library.path=<span class="variable">$HADOOP_COMMON_LIB_NATIVE_DIR</span>"</span></span><br></pre></td></tr></table></figure></li><li><p>使配置生效</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop <span class="built_in">version</span>  <span class="comment"># output the information of the version of the hadoop</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-2、-Hadoop伪分布式配置"><a href="#4-2、-Hadoop伪分布式配置" class="headerlink" title="4.2、 Hadoop伪分布式配置"></a>4.2、 Hadoop伪分布式配置</h3><ul><li><p>修改配置文件<code>hadoop-env.sh</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到工作目录</span></span><br><span class="line">cd /opt/hadoop/etc/hadoop</span><br><span class="line"><span class="comment"># 打开配置文件</span></span><br><span class="line">vim hadoop-env.sh</span><br><span class="line"><span class="comment"># 直接加上下面代码</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/opt/jdk</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件<code>core-site.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://219.223.243.131:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>   219.223.243.131是我的节点所在主机的ip,9000为默认的端口，不用更改</p></blockquote><ul><li><p>修改配置文件<code>hdfs-site.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.nameservices<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hadoop-cluster<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///data/hadoop/hdfs/nn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.checkpoint.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///data/hadoop/hdfs/snn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.checkpoint.edits.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///data/hadoop/hdfs/snn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///data/hadoop/hdfs/dn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改配置文件<code>mapred-site.xml</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">    <span class="params">&lt;name&gt;</span>mapreduce.framework.name<span class="params">&lt;/name&gt;</span></span><br><span class="line">    <span class="params">&lt;value&gt;</span>yarn<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">    <span class="params">&lt;name&gt;</span>mapreduce.admin.user.env<span class="params">&lt;/name&gt;</span></span><br><span class="line">    <span class="params">&lt;value&gt;</span>HADOOP_MAPRED_HOME=$HADOOP_HOME<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">    <span class="params">&lt;name&gt;</span>yarn.app.mapreduce.am.env<span class="params">&lt;/name&gt;</span></span><br><span class="line">    <span class="params">&lt;value&gt;</span>HADOOP_MAPRED_HOME=$HADOOP_HOME<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">    <span class="params">&lt;name&gt;</span>mapreduce.map.env<span class="params">&lt;/name&gt;</span></span><br><span class="line">    <span class="params">&lt;value&gt;</span>HADOOP_MAPRED_HOME=$HADOOP_HOME<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">    <span class="params">&lt;name&gt;</span>mapreduce.reduce.env<span class="params">&lt;/name&gt;</span></span><br><span class="line">    <span class="params">&lt;value&gt;</span>HADOOP_MAPRED_HOME=$HADOOP_HOME<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">    <span class="params">&lt;name&gt;</span>mapreduce.application.classpath<span class="params">&lt;/name&gt;</span></span><br><span class="line">    <span class="params">&lt;value&gt;</span></span><br><span class="line">         <span class="meta-keyword">/opt/</span>hadoop<span class="meta-keyword">/etc/</span>hadoop,</span><br><span class="line">         <span class="meta-keyword">/opt/</span>hadoop<span class="meta-keyword">/share/</span>hadoop<span class="meta-keyword">/common/</span>*,</span><br><span class="line">         <span class="meta-keyword">/opt/</span>hadoop<span class="meta-keyword">/share/</span>hadoop<span class="meta-keyword">/common/</span>lib<span class="comment">/*,</span></span><br><span class="line"><span class="comment">         /opt/hadoop/share/hadoop/hdfs/*,</span></span><br><span class="line"><span class="comment">         /opt/hadoop/share/hadoop/hdfs/lib/*,</span></span><br><span class="line"><span class="comment">         /opt/hadoop/share/hadoop/mapreduce/*,</span></span><br><span class="line"><span class="comment">         /opt/hadoop/share/hadoop/mapreduce/lib/*,</span></span><br><span class="line"><span class="comment">         /opt/hadoop/share/hadoop/yarn/*,</span></span><br><span class="line"><span class="comment">         /opt/hadoop/share/hadoop/yarn/lib/*</span></span><br><span class="line"><span class="comment">    &lt;/value&gt;</span></span><br><span class="line"><span class="comment">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改配置文件<code>yarn-site.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定ResourceManager的地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>219.223.243.131<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定reducer获取数据的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.local-dirs<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///data/hadoop/yarn/nm<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-pmem-ratio<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>4<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.pmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建相关目录</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sudo</span> mkdir -p /<span class="class"><span class="keyword">data</span>/hadoop/hdfs/nn</span></span><br><span class="line"><span class="title">sudo</span> mkdir -p /<span class="class"><span class="keyword">data</span>/hadoop/hdfs/dn</span></span><br><span class="line"><span class="title">sudo</span> mkdir -p /<span class="class"><span class="keyword">data</span>/hadoop/hdfs/snn</span></span><br><span class="line"><span class="title">sudo</span> mkdir -p /<span class="class"><span class="keyword">data</span>/hadoop/yarn/nm</span></span><br><span class="line"><span class="meta"># 然后给这些目录设置读写权限，</span></span><br><span class="line"><span class="meta"># 如果使用当前的用户（非root用户）启动相关进程，`/data`必须具有相应的读写权限</span></span><br><span class="line"><span class="meta"># 给`/data`目录及其子目录设置读写权限。 -R 递归设置权限</span></span><br><span class="line"><span class="title">sudo</span> chmod -<span class="type">R</span> <span class="number">777</span> /<span class="class"><span class="keyword">data</span></span></span><br></pre></td></tr></table></figure></li><li><p>对HDFS集群进行格式化，HDFS集群是用来存储数据的</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -<span class="built_in">format</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3、-启动集群"><a href="#4-3、-启动集群" class="headerlink" title="4.3、 启动集群"></a>4.3、 启动集群</h3><ol><li><p>启动HDFS集群</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动主节点</span></span><br><span class="line">hdfs <span class="comment">--daemon start namenode </span></span><br><span class="line"><span class="comment"># 启动从节点</span></span><br><span class="line">hdfs <span class="comment">--daemon start datanode </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证节点是否启动，输入一下命令</span></span><br><span class="line">jps <span class="comment"># 看是否出现namenode和datanode</span></span><br></pre></td></tr></table></figure></li><li><p>启动YARN集群</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 启动资源管理器</span></span><br><span class="line">yarn --daemon start resourcemanager</span><br><span class="line"><span class="meta"># 启动节点管理器</span></span><br><span class="line">yarn --daemon start nodemanager</span><br><span class="line"></span><br><span class="line"><span class="meta"># 验证是否启动，同样是采用`jps`命令，看是否出想相关进程</span></span><br></pre></td></tr></table></figure></li><li><p>启动作业历史服务器</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapred --daemon start historyserver</span><br><span class="line"># 同样采用`jps`命令查看是否启动成功</span><br></pre></td></tr></table></figure></li><li><p>HDFS和YARN集群都有对应的WEB监控页面。</p><blockquote><p> HDFS: <a href="http://ip:9870" target="_blank" rel="noopener">http://ip:9870</a> 或者 localhost:9870</p></blockquote></li></ol><p><img src="https://wx2.sinaimg.cn/mw1024/e0db46edgy1fq6ro1zxiuj20so0pvq5f.jpg" alt="图片名称" align="center"></p><p><img src="https://wx2.sinaimg.cn/mw1024/e0db46edgy1fq6ro1u9z0j20sh0ntgmn.jpg" alt="图片名称" align="center"></p><blockquote><p> YARN: <a href="http://ip:8088" target="_blank" rel="noopener">http://ip:8088</a></p></blockquote><p><img src="https://wx4.sinaimg.cn/mw1024/e0db46edgy1fq6ro1zitoj21ag0gstbh.jpg" alt="图片名称" align="center"></p><ol start="5"><li><p>HDFS集群的简单操作命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -<span class="keyword">ls</span> /   # 相当于<span class="keyword">shell</span>中的 <span class="keyword">ll</span></span><br><span class="line">hdfs dfsadmin -safemode leave  # 关闭安全模式</span><br><span class="line">hdfs dfs -<span class="built_in">mkdir</span> -<span class="keyword">p</span> /user/<span class="built_in">input</span>  # 在hdfs文件系统上级联创建文件/user/<span class="built_in">input</span>，</span><br></pre></td></tr></table></figure></li><li><p>YARN集群examples测试</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 计算PI值的作业</span></span><br><span class="line">yarn jar <span class="meta-keyword">/opt/</span>hadoop<span class="meta-keyword">/share/</span>hadoop<span class="meta-keyword">/mapreduce/</span>hadoop-mapreduce-examples-*.jar pi <span class="number">4</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># wordcount例子</span></span><br><span class="line"><span class="meta"># 首先创建一个输入文件，并上传到hdfs文件系统上</span></span><br><span class="line">hdfs dfs -put input <span class="meta-keyword">/user/</span>heany</span><br><span class="line"><span class="meta"># 然后执行</span></span><br><span class="line">yarn jar <span class="meta-keyword">/opt/</span>hadoop<span class="meta-keyword">/share/</span>hadoop<span class="meta-keyword">/mapreduce/</span>hadoop-mapreduce-examples-*.jar wordcount input output</span><br><span class="line"><span class="meta"># 用命令行查看结果</span></span><br><span class="line">hdfs dfs -cat <span class="meta-keyword">/user/</span>output/part-r<span class="number">-00000</span></span><br><span class="line"><span class="meta"># 或者在网页上查看</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="五、-安装Spark"><a href="#五、-安装Spark" class="headerlink" title="五、 安装Spark"></a>五、 安装Spark</h2><h3 id="5-1、-下载安装Spark"><a href="#5-1、-下载安装Spark" class="headerlink" title="5.1、 下载安装Spark"></a>5.1、 下载安装Spark</h3><ul><li>下载Spark(笔者下载的是spark-2.3.0-bin-hadoop2.7.tgz)</li><li><p>解压下载的Spark包</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -zxvf spark<span class="number">-2.3</span><span class="number">.0</span>-bin-hadoop2<span class="number">.7</span>.tgz -C /opt</span><br></pre></td></tr></table></figure></li><li><p>重命名</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到工作目录</span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">/opt</span></span><br><span class="line">sudo mv spark-2.3.0-bin-hadoop2.7 spark</span><br></pre></td></tr></table></figure></li><li><p>添加环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"><span class="comment"># 在最后添加下面的代码</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">SPARK_HOME</span>=/opt/spark</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$SPARK_HOME</span>/bin:$SPARK_HOME/sbin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>修改文件的权限</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/opt</span></span><br><span class="line">sudo chown -R yourname<span class="function">:yourname</span> <span class="string">./spark</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-2、-修改配置文件"><a href="#5-2、-修改配置文件" class="headerlink" title="5.2、 修改配置文件"></a>5.2、 修改配置文件</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 拷贝配置文件</span><br><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/spark</span><br><span class="line"><span class="keyword">cp</span> ./<span class="keyword">conf</span>/spark-env.<span class="keyword">sh</span>.template ./<span class="keyword">conf</span>/spark-env.<span class="keyword">sh</span></span><br><span class="line"></span><br><span class="line"># 修改配置文件</span><br><span class="line"><span class="keyword">vim</span> ./<span class="keyword">conf</span>/spark-env.<span class="keyword">sh</span></span><br><span class="line"># 在最后添加下面的代码</span><br><span class="line">export SPARK_DIST_CLASSPATH=$(/<span class="keyword">opt</span>/hadoop/bin/hadoop classpath)</span><br><span class="line">export JAVA_HOME=/<span class="keyword">opt</span>/jdk</span><br></pre></td></tr></table></figure><h3 id="5-3、运行examples验证安装"><a href="#5-3、运行examples验证安装" class="headerlink" title="5.3、运行examples验证安装"></a>5.3、运行examples验证安装</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/opt/</span>spark<span class="meta-keyword">/bin/</span>run-example SparkPi <span class="number">2</span>&gt;<span class="variable">&amp;1</span> | grep <span class="string">"Pi is roughly"</span></span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="meta"># Pi is roughly 3.143635718178591</span></span><br></pre></td></tr></table></figure><h3 id="5-4、-脚本启动Hadoop和Spark"><a href="#5-4、-脚本启动Hadoop和Spark" class="headerlink" title="5.4、 脚本启动Hadoop和Spark"></a>5.4、 脚本启动Hadoop和Spark</h3><ul><li><p>启动spark</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">opt</span>/spark/sbin/start-<span class="keyword">all</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></li><li><p>通过WEB页面查看</p><blockquote><p> 浏览器输入地址：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p></blockquote></li><li><p>编写自动化脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动Hadoop以及Spark脚本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 启动Hadoop以及yarn</span></span><br><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br><span class="line"><span class="comment"># 启动历史服务器</span></span><br><span class="line"><span class="comment">#mr-jobhistory-daemon.sh start historyserver</span></span><br><span class="line">mapred --daemon start historyserver</span><br><span class="line"><span class="comment"># 启动Spark</span></span><br><span class="line">/opt/spark/sbin/start-all.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止Hadoop以及Spark脚本</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 停止Hadoop以及yarn</span></span><br><span class="line">stop-dfs.sh</span><br><span class="line">stop-yarn.sh</span><br><span class="line"><span class="comment"># 停止历史服务器</span></span><br><span class="line"><span class="comment">#mr-jobhistory-daemon.sh stop historyserver</span></span><br><span class="line">mapred --daemon stop historyserver</span><br><span class="line"><span class="comment"># 停止Spark</span></span><br><span class="line">/opt/spark/sbin/stop-all.sh</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;最近导师带的项目是与大数据相关，感觉这几年大数据技术还挺火的，就想着也去学一下，丰富自己的技能栈。本文主要讲的是hadoop+spark的环境搭建,然后使用自带的examples测试环境，这里不涉及原理介绍。
    
    </summary>
    
      <category term="分布式与大数据" scheme="http://heany.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Ubuntu 17.10 hadoop Spark" scheme="http://heany.github.io/tags/Ubuntu-17-10-hadoop-Spark/"/>
    
  </entry>
  
  <entry>
    <title>Shell Script学习笔记</title>
    <link href="http://heany.github.io/2018/03/31/Shell-Script%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://heany.github.io/2018/03/31/Shell-Script学习笔记/</id>
    <published>2018-03-31T06:09:19.000Z</published>
    <updated>2019-01-26T14:47:30.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h2><p>最近开始使用Linux系统，经常操作terminal，经常使用Linux下的bash来进行一些重复的操作，因此想学习<code>shell script</code>来简化一些安装软件的步骤，实现自动化部署一些应用，节约时间。本文介绍了一些bash命令的一些技巧，然后详细地讲解了<strong>正则表达式与文件格式化处理</strong>，并且对于每一个操作都有相关的实例进行练习，加强理解;<strong><code>shell script</code></strong>，同样对于每一个功能都有相应的实例进行练习，可以说～非常适合新手来阅读学习了！</p><h2 id="二、-基础知识"><a href="#二、-基础知识" class="headerlink" title="二、 基础知识"></a>二、 基础知识</h2><p>&nbsp;&nbsp;什么是 shell script (程序化脚本) 呢？就字面上的意义，我们将他分为两部份。 在『 shell 』部分，我们在bash当中已经提过了，那是一个文字介面底下让我们与系统沟通的一个工具介面。那么『 script 』是啥？ 字面上的意义， script 是『脚本、剧本』的意思。整句话是说， shell script 是针对 shell 所写的『剧本！』<br>&nbsp;&nbsp;什么东西啊？其实， shell script 是利用 shell 的功能所写的一个『程序 (program)』，这个程序是使用纯文字档，将一些 shell 的语法与命令(含外部命令)写在里面， 搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。<br>&nbsp;&nbsp;shell script 更提供阵列、回圈、条件与逻辑判断等重要功能，让使用者也可以直接以 shell 来撰写程序，而不必使用类似 C 程序语言等传统程序撰写的语法呢！</p><h3 id="2-1-一些shell命令的基础知识及技巧"><a href="#2-1-一些shell命令的基础知识及技巧" class="headerlink" title="2.1 一些shell命令的基础知识及技巧"></a>2.1 一些shell命令的基础知识及技巧</h3><p>&nbsp;&nbsp;一些快捷键：<br><code>^A</code> :鼠标光标移到命令最左端<br><code>^E</code> :鼠标光标移到命令最右端<br><code>^k</code> :删除鼠标光标后面的命令<br><code>^u</code> :删除鼠标光标前面的命令<br><code>^s</code> :锁定terminal<br><code>^Q</code> :解锁<br><code>^y</code> :撤销上一次操作<br><code>^D</code> :输入结束（EOF），例如邮件结束的时候<br><code>^Z</code> :暂停目前的命令</p><p><code>cat</code>命令的一些技巧：以下代码将内容写入file<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="xml"><span class="tag">&lt;&lt; <span class="attr">EOF</span> &gt;</span></span> file</span><br><span class="line"><span class="quote">&gt; hello</span></span><br><span class="line"><span class="quote">&gt; world</span></span><br><span class="line"><span class="quote">&gt; ......</span></span><br><span class="line"><span class="quote">&gt; EOF</span></span><br></pre></td></tr></table></figure></p><blockquote><p> 管道及tee</p></blockquote><p>管道<br>:    管道的作用是将前一条命令的输出变成管道后命令的输入<br>        ls /bin | wc -l   ##统计 ls /bin命令输出的行数<br>    系统中错误的输出是无法通过管道的<br>    用 <code>2&gt;&amp;1</code> 可以把错误的输出编号由2变成1</p><p>tee<br>:    <code>tee</code>复制输出到指定位置<br>        data | tee file |wc -l  ##tee命令复制date命令的输出到file中，并统计输出行数</p><h3 id="2-2-脚本中调用其他的解释器-如python-执行的代码"><a href="#2-2-脚本中调用其他的解释器-如python-执行的代码" class="headerlink" title="2.2 脚本中调用其他的解释器(如python)执行的代码"></a>2.2 脚本中调用其他的解释器(如python)执行的代码</h3><p>&nbsp;&nbsp;shell script中第一行通常需要一行指令指定执行此脚本的解释器,如：</p><pre><code>#!/bin/bash#!/bin/python#!/bin/perl</code></pre><p>以上分别指定了常用的三种脚本的解释器，</p><blockquote><p> 多条命令执行</p></blockquote><ol><li>用<code>;</code>号分隔，这种方式各条命令之间没有逻辑性<br> cd; ls; ll</li><li>用逻辑连接符<code>&amp;&amp;</code> <code>||</code>来连接。<br> ./confirgure &amp;&amp; make &amp;&amp; make install  ##必须前面的命令执行成功，才能执行后面的命令<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> con1</span><br><span class="line">    com2</span><br><span class="line"><span class="keyword">else</span> com3</span><br></pre></td></tr></table></figure></li></ol><p>上面这段代码相当于<br>    com1 &amp;&amp; com2 &amp;&amp; com3</p><blockquote><p> shell通配符</p></blockquote><p><code>*</code> :任意个<br><code>?</code> :1个<br><code>[]</code>:匹配括号里面的一个</p><blockquote><p> <code>echo</code>输出颜色文本</p></blockquote><pre><code>echo -e &quot;\e[1;31m This is red text. \e[0m&quot;</code></pre><blockquote><p> <code>printf</code>格式化输出<br>    printf “hello\n”</p></blockquote><blockquote><p> <code>read</code>命令变量键盘读取使用方法如下：</p></blockquote><pre><code>read [-pt] variableparas:-p :后面接提示符-t :后面接等待的“秒数”example:read atestread -p &quot;please a string:&quot; -t 30 atest</code></pre><blockquote><p> <code>declare/typeset</code>命令：声明变量的类型：默认类型为字符串</p></blockquote><pre><code>declare [-aixr] variableparas:-a :将后面的variable的变量定义为数组（array）类型-i :定义为integer类型-x :用法与export一样，将后面的变量变成环境变量-r :将变量设置成为readonly类型，该变量不可被更改，也不能重设example:sum=100+300+50echo $sum  # sum=100+300+50declare -i sum=100+300+50echo $sum    #450</code></pre><blockquote><p> <code>array</code>数组变量类型;读取时：${数组}</p></blockquote><pre><code>var[index]=contentexample:var[1]=&quot;Tom&quot;var[2]=&quot;tony&quot;echo &quot;${var[1]},${var[2]}&quot;   #Tom,tony</code></pre><blockquote><p> <code>alias</code>、<code>unalias</code>命令别名设置：;<br>    alias lm=’ls -l | more’  #lm执行的是ls -all more<br>    unalias lm   #去掉lm命令的别名</p></blockquote><blockquote><p> <code>history</code>查询历史命令</p></blockquote><pre><code>history [n]history [-c]history [-raw]paras:n :数字，列出最近的n条命令行的意思-c ：将目前的shell中的所有history内容全部消除-a : 将新增的history命令新增进去histfiles,或默认写入~/.bash_history-r : 将histfiles的内容读到目前这个shell的history中-w : 将目前的history记忆内容写进histfiles中。另：！number ：执行第几条命令的意思!command ：由最近的命令向前搜寻命令串开头command的那个命令，并执行!! : 执行上一个命令</code></pre><h3 id="2-3-数据流重定向-redirect"><a href="#2-3-数据流重定向-redirect" class="headerlink" title="2.3 数据流重定向(redirect)"></a>2.3 数据流重定向(redirect)</h3><blockquote><p> <strong>数据流重定向</strong>就是将某个命令执行后应该要出现在屏幕上的数据传输到其他的地方。</p></blockquote><ul><li>标准输入(stdin):代码为0，使用<code>&lt;</code>(覆盖)或<code>&lt;&lt;</code>(追加)</li><li>标准输出(stdout)：代码为1，使用<code>&gt;</code>或<code>&gt;&gt;</code></li><li>标准错误输出(stderr):代码为2，使用<code>2&gt;</code>或<code>2&gt;&gt;</code></li></ul><blockquote><p> <code>/dev/null</code>垃圾桶黑洞设备</p></blockquote><pre><code>find /home -name .bashrc 2&gt; /dec/null  #将错误的数据丢弃，屏幕上显示正确的数据## /home/heany/.bashrc</code></pre><blockquote><p> <code>standard input</code>:<code>&lt;</code>与<code>&lt;&lt;</code></p></blockquote><pre><code>cat &gt; catfile &lt; ~/.bashrc #用stdin替代键盘的输入以创建新文件的简单流程cat &gt; catfile &lt;&lt; &quot;eof&quot;&gt; This is a test.&gt; OK now stop&gt; eof    #输入这个关键字，立刻就结束不需要输入[ctrl+D]</code></pre><h3 id="2-4-管道命令-pipe"><a href="#2-4-管道命令-pipe" class="headerlink" title="2.4 管道命令(pipe)"></a>2.4 管道命令(pipe)</h3><blockquote><p> <strong>管道命令</strong>使用<code>|</code>这个界定符号，仅能处理经由前面一个命令传来的正确的信息，也就是standard output的信息，对于standard error并没有直接处理的能力。管道后面接的第一个数据必定是”命令“，而且这个命令必须要能够接收standard input的数据才行，这样的命令才可以是“管道命令”，例如less, more,head, tail等。而ls, cp ,mv这些则不是管道命令，因为他们不会接收来自stdin的数据。</p></blockquote><h4 id="2-4-1-选取命令：cut-grep"><a href="#2-4-1-选取命令：cut-grep" class="headerlink" title="2.4.1 选取命令：cut,grep"></a>2.4.1 选取命令：cut,grep</h4><p>  <em>选取命令</em>就是将一段数据经过分析后，取出我们所想要的，或者是经由分析关键字，得我们所想要的哪一行，通常是针对”行”来分析的。</p><blockquote><p> <code>cut</code>这个命令可以将一段信息的某一段“切出来”，处理信息以“行”为单位。</p></blockquote><pre><code>cut -d &apos;分隔字符&apos; -f fields  #用于分隔字符cut -c 字符范围     #用于排列整齐的信息paras:-f ：依据-d的分隔字符将一段信息切割成数段，用-f取出第几段的意思。-c ：以字符的单位取出固定字符区间examples:echo $PATH | cut -d &apos;:&apos; -f 5   ## 将echo $PATH结果以&quot;:&quot;分隔，，找到第5个export | cut -c 12-  ## 将export输出的信息取得第12字符后的所有字符串</code></pre><blockquote><p> <code>grep</code>命令是分析一行信息，若当中有我们需要的信息，就将该行拿出来。<br>    grep [-acinv] [–color=auto] ‘查找字符串’ filename<br>    paras:<br>    -a:将binary文件以text文件的形式查找数据<br>    -c:计算找到”查找字符串”的次数<br>    -i:忽略大小写的不同，所以大小写视为相同<br>    -n:顺便输出行号<br>    -v: 反向选择，即显示没有”查找字符串”内容的那一行<br>    –color=auto : 可以将找到的关键字部分加上颜色显示<br>    examples:<br>    last | grep ‘root’  #将last中有出现root的那一行就取出来<br>    last | grep -v ‘root’ # 与上面相反，只要没有root就取出<br>    last | grep ‘root’ | cut -d ‘’ -f 1  #在取出root后，利用上一个命令cut的处理，就能取出第一列</p></blockquote><h4 id="2-4-2-排序命令：sort-wc-uniq"><a href="#2-4-2-排序命令：sort-wc-uniq" class="headerlink" title="2.4.2 排序命令：sort, wc ,uniq"></a>2.4.2 排序命令：sort, wc ,uniq</h4><blockquote><p> <code>sort</code>排序</p></blockquote><pre><code>sort [-fbMnrtuk] [file or stdin]paras:-f : 忽略大小写的差异-b : 忽略最前面的空格符部分-M : 以月份的名字来排序-n : 使用”纯数字“进行排序-r : 反向排序-u : 就是uniq，相同的数据中，仅出现一行代表-t : 分隔符，默认是用[Tab]键来分隔-k : 以那个区间(field)来进行排序的意思examples:cat /etc/passwd | sort -t &apos;:&apos; -k 3  #以:来分隔，以第三列来排序last | cut -d &apos;&apos; -f1 | sort  #利用last将输出的数据仅取账号，并加以排序</code></pre><blockquote><p> <code>uniq</code>将重复的数字仅列出一个显示</p></blockquote><pre><code>uniq [-ic]paras:-i : 忽略大小写字符的不同-c : 进行计数examples:last | cut -d &apos;&apos; -f1 | sort |uniq  # 使用last将账号列出，仅取出账号列，进行排序后取出最后一位</code></pre><blockquote><p> <code>wc</code>计算输出信息的整体数据</p></blockquote><pre><code>wc [-lwm]paras:-l : 仅列出行-w : 仅列出多少字-m : 多少字符examples:cat /etc/man.config | wc  #列出config里面到底有多少相关行数、字数、字符数，分别输出三列</code></pre><h4 id="2-4-3-双向重定向：tee"><a href="#2-4-3-双向重定向：tee" class="headerlink" title="2.4.3 双向重定向：tee"></a>2.4.3 双向重定向：tee</h4><pre><code>*tee*会同时将数据流送与文件于屏幕，而输出到屏幕的就是standout,可以让下个命令继续处理。tee [-a] fileparas:-a : 以累加(append)的方式，将数据加入file当中。examples:last | tee [-a] last.list | cut -d &apos;&apos; -f1   #将last的输出存一份last.list文件中 </code></pre><h4 id="2-4-4-字符转换命令：tr-col-join-paste-expand"><a href="#2-4-4-字符转换命令：tr-col-join-paste-expand" class="headerlink" title="2.4.4 字符转换命令：tr, col, join, paste, expand"></a>2.4.4 字符转换命令：tr, col, join, paste, expand</h4><p><em>主要介绍这些字符转换命令在管道中的使用方法</em></p><blockquote><p> <code>tr</code>可以用来删除一段信息当中的文字，或者是进行文字信息的替换</p></blockquote><pre><code>tr [-ds] SET1 ....paras:-d : 删除信息当中的SET1这个字符串，-s : 替换掉重复的字符串examples:last | tr [a-z] [A-Z]  #将last输出的信息中所有的小写字符变成大写字符</code></pre><blockquote><p> <code>col</code></p></blockquote><pre><code>col [-xb]paras:-x : 将Tab键转换成对等的空格键-b : 在文字内有反斜杠\时，仅保留反斜杠最后接的那个字符</code></pre><blockquote><p> <code>join</code>处理两个文件之间的数据，而且主要是将两个文件当中有相同数据的那一行加在一起。</p></blockquote><pre><code>join [-ti12] file1 file2paras:-t : join默认以空格符分隔数据，并且对比”第一个字段“的数据，如果两个文件相同，则将两条数据连成一行，且第一个字段放在第一个。-i : 忽略大小写的差异-1 : 这个是数字的1,代表第一个文件要用哪个字段来分析的意思-2 : 代表第二个文件要用哪个字段来分析的意思。examples:join -t &apos;:&apos; /etc/passwd /etc/shadow #将两个文件第一个字段相同者整合成一行</code></pre><blockquote><p> <code>paste</code>直接将两行贴在一起，且中间一[tab]键隔开。</p></blockquote><pre><code>paste [-d] file1 file2paras:-d : 后面可以接分隔字符，默认是以[tab]来分隔的-  : 如果file部分写成 - ，表示来自standard input的数据的意思examples:paste /etc/passwd /etc/shadow  # 将两个文件的同一行贴在一起</code></pre><h4 id="2-4-5-切割命令：split"><a href="#2-4-5-切割命令：split" class="headerlink" title="2.4.5 切割命令：split"></a>2.4.5 切割命令：split</h4><p><em>切割命令</em>将一个大文件依据文件大小或行数来切割成为小文件</p><pre><code>split [-bl] file PREFIXparas:-b : 后面可接欲切割成的文件大小，可加单位-l : 以行数来进行切割PREFIX : 代表前导符，可作为切割文件的前导文字。examples:cd /tmp; split -b 300k /etc/termcap termcap  # 将/etc/termcap分成300K一个文件ls -al / | split -l 10 -lsroot #将使用ls-al /输出的信息中，每10行记录成一个文件</code></pre><h2 id="三、-正则表达式与文件格式化处理"><a href="#三、-正则表达式与文件格式化处理" class="headerlink" title="三、 正则表达式与文件格式化处理"></a>三、 正则表达式与文件格式化处理</h2><h3 id="3-1、-正则表达式概念-Regular-Expression"><a href="#3-1、-正则表达式概念-Regular-Expression" class="headerlink" title="3.1、 正则表达式概念(Regular Expression)"></a>3.1、 正则表达式概念(Regular Expression)</h3><p>  简单的说,正则表达式就是处理字串的方法,他是以行为单位来进行字串的处理行为, 正则<br>表达式通过一些特殊符号的辅助,可以让使用者轻易的达到“搜寻/删除/取代”某特定字串的处<br>理程序!<span style="color:#F00">强大的字符串处理能力</span></p><h3 id="3-2、-基础正则表达式"><a href="#3-2、-基础正则表达式" class="headerlink" title="3.2、 基础正则表达式"></a>3.2、 基础正则表达式</h3><h4 id="3-2-1、-语系对正则表达式的影响"><a href="#3-2-1、-语系对正则表达式的影响" class="headerlink" title="3.2.1、 语系对正则表达式的影响"></a>3.2.1、 语系对正则表达式的影响</h4><p>&nbsp;&nbsp;计算机文件其实记录的仅有0与1,我们看到的字符文字与数字都是通过编码表转换来的。由于不同语系的编码数据并不相同，所有就会造成数据提取结果的差异了。举例来说，在英文大小写的编码顺序中，zh_TW.big5及C这两种语系的输出结果分别如下:</p><ul><li>LANG=C时：0 1 2 3 4 … A B C D … Z abcd … z</li><li>LANG=zh_TW时: 0 1 2 3 4 … a A b B C c … z Z</li></ul><p>上面的顺序是编码的顺序，我们可以很清楚的发现这两种语系明显就是不一样！如果你想要提取大写字符而使用[A-Z]时，会发现会发现LANG=C确实可以仅捉到大写字符 (因为是连续的),但是如果 LANG=zh_TW.big5时,就会发现到, 连同小写的b-z也会被撷取出来!因为就<br>编码的顺序来看,big5语系可以撷取到“ A b B c C … z Z ”这一堆字符哩! 所以,使用正则表<br>达式时,需要特别留意当时环境的语系为何, 否则可能会发现与别人不相同的撷取结果喔!一般练习时采用<code>LANG=C</code>这个语系。</p><blockquote><p> 一些特殊符号的代表意义</p></blockquote><p><img src="https://wx4.sinaimg.cn/mw1024/e0db46edgy1fq7iwmdmuzj20og0fndj2.jpg" alt="图片名称" align="center"></p><h4 id="3-2-2、-grep的一些进阶选项"><a href="#3-2-2、-grep的一些进阶选项" class="headerlink" title="3.2.2、 grep的一些进阶选项"></a>3.2.2、 grep的一些进阶选项</h4><p><img src="https://wx1.sinaimg.cn/mw1024/e0db46edgy1fq7j5i0kq8j20zl0mtgul.jpg" alt="图片名称" align="center"></p><blockquote><p> grep是一个很常见也很常用的指令，它最重要的功能就是进行字符串数据的比对，然后将符合使用者需求的字串行印出来。<strong>需要说明的是“grep 在数据中查寻一个字串时,是以 “整行” 为单位来进行数据的撷取的!”</strong>也就是说,假如一个文件内有 10 行,其中有两行具有你所搜寻<br>的字串,则将那两行显示在屏幕上,其他的就丢弃了!</p></blockquote><h4 id="3-2-3、-基础正则表达式练习"><a href="#3-2-3、-基础正则表达式练习" class="headerlink" title="3.2.3、 基础正则表达式练习"></a>3.2.3、 基础正则表达式练习</h4><p>练习用文件下载如下：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">wget http://linux.vbird.org/linux_basic/<span class="number">0330</span>regularex/regular_express.txt</span><br><span class="line"></span><br><span class="line"># content</span><br><span class="line"><span class="string">"Open Source"</span> <span class="keyword">is</span> a good mechanism <span class="keyword">to</span> develop programs.</span><br><span class="line">apple <span class="keyword">is</span> my favorite food.</span><br><span class="line">Football game <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">use</span> feet only.</span><br><span class="line">this dress doesn<span class="symbol">'t</span> fit me.</span><br><span class="line">However, this dress <span class="keyword">is</span> about $ <span class="number">3183</span> dollars.^M</span><br><span class="line">GNU <span class="keyword">is</span> free air <span class="keyword">not</span> free beer.^M</span><br><span class="line">Her hair <span class="keyword">is</span> very beauty.^M</span><br><span class="line">I can<span class="symbol">'t</span> finish the test.^M</span><br><span class="line">Oh! The soup taste good.^M</span><br><span class="line">motorcycle <span class="keyword">is</span> cheap than car.</span><br><span class="line">This window <span class="keyword">is</span> clear.</span><br><span class="line">the symbol '*' <span class="keyword">is</span> represented as start.</span><br><span class="line">Oh!     My god!</span><br><span class="line">The gd software <span class="keyword">is</span> a <span class="keyword">library</span> <span class="keyword">for</span> drafting programs.^M</span><br><span class="line">You are the best <span class="keyword">is</span> mean you are the no. <span class="number">1</span>.</span><br><span class="line">The world &lt;Happy&gt; <span class="keyword">is</span> the same <span class="keyword">with</span> <span class="string">"glad"</span>.</span><br><span class="line">I like dog.</span><br><span class="line">google <span class="keyword">is</span> the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">goooooogle yes!</span><br><span class="line">go! go! Let<span class="symbol">'s</span> go.</span><br><span class="line"># I am VBird</span><br></pre></td></tr></table></figure></p><ul><li>例题一、搜寻特定字串</li></ul><p>从上面下载的文件中<strong>取the这个特定字串</strong>，最简单的方式就是这样：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="comment">'the' regular_express.txt </span></span><br><span class="line"></span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="number">8</span>:I can<span class="comment">'t finish the test.</span></span><br><span class="line"><span class="number">12</span>:the symbol <span class="comment">'*' is represented as start.</span></span><br><span class="line"><span class="number">15</span>:You are the best <span class="keyword">is</span> mean you are the no. <span class="number">1.</span></span><br><span class="line"><span class="number">16</span>:The world &lt;Happy&gt; <span class="keyword">is</span> the same <span class="keyword">with</span> <span class="string">"glad"</span>.</span><br><span class="line"><span class="number">18</span>:google <span class="keyword">is</span> the best tools <span class="keyword">for</span> search keyword.</span><br></pre></td></tr></table></figure></p><p>如果要<strong>反向选择</strong>，也就是当该行没有’the’这个字串时才显示在屏幕上，那就直接使用：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">grep -vn <span class="comment">'the' regular_express.txt </span></span><br><span class="line"></span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="number">1</span>:<span class="string">"Open Source"</span> <span class="keyword">is</span> a good mechanism <span class="keyword">to</span> develop programs.</span><br><span class="line"><span class="number">2</span>:apple <span class="keyword">is</span> my favorite food.</span><br><span class="line"><span class="number">3</span>:Football game <span class="keyword">is</span> <span class="keyword">not</span> use feet only.</span><br><span class="line"><span class="number">4</span>:this dress doesn<span class="comment">'t fit me.</span></span><br><span class="line"><span class="number">5</span>:However, this dress <span class="keyword">is</span> about $ <span class="number">3183</span> dollars.</span><br><span class="line"><span class="number">6</span>:GNU <span class="keyword">is</span> free air <span class="keyword">not</span> free beer.</span><br><span class="line"><span class="number">7</span>:Her hair <span class="keyword">is</span> very beauty.</span><br><span class="line"><span class="number">9</span>:Oh! The soup taste good.</span><br><span class="line"><span class="number">10</span>:motorcycle <span class="keyword">is</span> cheap than car.</span><br><span class="line"><span class="number">11</span>:This window <span class="keyword">is</span> clear.</span><br><span class="line"><span class="number">13</span>:Oh!  My god!</span><br><span class="line"><span class="number">14</span>:The gd software <span class="keyword">is</span> a library <span class="keyword">for</span> drafting programs.</span><br><span class="line"><span class="number">17</span>:I <span class="keyword">like</span> dog.</span><br><span class="line"><span class="number">19</span>:goooooogle yes!</span><br><span class="line"><span class="number">20</span>:go! go! <span class="keyword">Let</span><span class="comment">'s go.</span></span><br><span class="line"><span class="number">21</span>:<span class="meta"># I am VBird</span></span><br><span class="line"><span class="number">22</span>:</span><br></pre></td></tr></table></figure></p><p>如果想取得<strong>不论大小写</strong>的‘the’这个字串，则：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep -<span class="keyword">in</span> <span class="comment">'the' regular_express.txt </span></span><br><span class="line"></span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="number">8</span>:I can<span class="comment">'t finish the test.</span></span><br><span class="line"><span class="number">9</span>:Oh! The soup taste good.</span><br><span class="line"><span class="number">12</span>:the symbol <span class="comment">'*' is represented as start.</span></span><br><span class="line"><span class="number">14</span>:The gd software <span class="keyword">is</span> a library <span class="keyword">for</span> drafting programs.</span><br><span class="line"><span class="number">15</span>:You are the best <span class="keyword">is</span> mean you are the no. <span class="number">1.</span></span><br><span class="line"><span class="number">16</span>:The world &lt;Happy&gt; <span class="keyword">is</span> the same <span class="keyword">with</span> <span class="string">"glad"</span>.</span><br><span class="line"><span class="number">18</span>:google <span class="keyword">is</span> the best tools <span class="keyword">for</span> search keyword.</span><br></pre></td></tr></table></figure></p><ul><li>例题二、利用中括号[]来搜寻集合字符</li></ul><p>如果我想要搜寻test或taste这两个单字时,可以发现到,其实她们有共通的’t?st’存在~这<br>个时候,我可以这样来搜寻:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="comment">'t[ae]st' regular_express.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="number">8</span>:I can<span class="comment">'t finish the test.</span></span><br><span class="line"><span class="number">9</span>:Oh! The soup taste good.</span><br></pre></td></tr></table></figure></p><blockquote><p> <code>[]</code>这个里面不论有几个字符，都仅匹配某一个字符，，如果想要搜寻到有<code>oo</code>的字符串时，则使用下面的命令：</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">'oo'</span> regular_express.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">1</span><span class="symbol">:<span class="string">"Open Source"</span></span> is a good mechanism to develop programs.</span><br><span class="line"><span class="number">2</span><span class="symbol">:apple</span> is my favorite food.</span><br><span class="line"><span class="number">3</span><span class="symbol">:Football</span> game is <span class="keyword">not</span> <span class="keyword">use</span> feet only.</span><br><span class="line"><span class="number">9</span><span class="symbol">:Oh!</span> The soup taste good.</span><br><span class="line"><span class="number">18</span><span class="symbol">:google</span> is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line"><span class="number">19</span><span class="symbol">:goooooogle</span> yes!</span><br></pre></td></tr></table></figure><p>但是，如果我不想要<code>oo</code>前面有g的话呢？此时，可以利用在集合字符的反向选择来达成：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">'[^g]oo'</span> regular_express.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">2</span><span class="symbol">:apple</span> is my favorite food.</span><br><span class="line"><span class="number">3</span><span class="symbol">:Football</span> game is <span class="keyword">not</span> <span class="keyword">use</span> feet only.</span><br><span class="line"><span class="number">18</span><span class="symbol">:google</span> is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line"><span class="number">19</span><span class="symbol">:goooooogle</span> yes!</span><br></pre></td></tr></table></figure></p><p>如果我们不想要<code>oo</code>前面有小写字符，可以这样写：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">'[^a-z]oo'</span> regular_express.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">3</span><span class="symbol">:Football</span> game is <span class="keyword">not</span> <span class="keyword">use</span> feet only.</span><br></pre></td></tr></table></figure></p><blockquote><p> <strong>连续编码</strong>可以使用减号<code>-</code>，也可以使用如下的方法来取得前面的两个测试的结果：</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">'[^[:lower:]]oo'</span> regular_express.txt</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">3</span>:Football game <span class="keyword">is</span> <span class="keyword">not</span> use feet only.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取含数字的那一行</span></span><br><span class="line">grep -n <span class="string">'[[:digit:]]'</span> regular_express.txt</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">5</span>:However, <span class="keyword">this</span> dress <span class="keyword">is</span> about $ <span class="number">3183</span> dollars.</span><br><span class="line"><span class="number">15</span>:You are the best <span class="keyword">is</span> mean you are the <span class="literal">no</span>. <span class="number">1.</span></span><br></pre></td></tr></table></figure><ul><li>例题三、行首与行尾字符^$</li></ul><p>在上面例子中，可以查询到一行字串里面有<code>the</code>的，那如果我想要让<code>the</code>只在行首列出呢？这个时候就需要使用<strong>定位字符</strong>了！<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">'^the'</span> regular_express.txt </span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">12</span>:<span class="keyword">the</span> symbol <span class="string">'*'</span> is represented <span class="keyword">as</span> <span class="built_in">start</span>.</span><br></pre></td></tr></table></figure></p><p>如果我想<strong>开头是小写字符</strong>的那一行就列出呢？可以这样写：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="comment">'^[a-z]' regular_express.txt </span></span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="number">2</span>:apple <span class="keyword">is</span> my favorite food.</span><br><span class="line"><span class="number">4</span>:this dress doesn<span class="comment">'t fit me.</span></span><br><span class="line"><span class="number">10</span>:motorcycle <span class="keyword">is</span> cheap than car.</span><br><span class="line"><span class="number">12</span>:the symbol <span class="comment">'*' is represented as start.</span></span><br><span class="line"><span class="number">18</span>:google <span class="keyword">is</span> the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line"><span class="number">19</span>:goooooogle yes!</span><br><span class="line"><span class="number">20</span>:go! go! <span class="keyword">Let</span><span class="comment">'s go.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 也可以使用下面的命令来实现</span></span><br><span class="line">grep -n <span class="comment">'^[[:lower:]]' regular_express.txt</span></span><br></pre></td></tr></table></figure></p><p>如果我不想要开头是<strong>英文字母</strong>，则可以是这样：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="comment">'^[^a-zA-Z]' regular_express.txt </span></span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="number">1</span>:<span class="string">"Open Source"</span> <span class="keyword">is</span> a good mechanism <span class="keyword">to</span> develop programs.</span><br><span class="line"><span class="number">21</span>:<span class="meta"># I am VBird</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 也可以这样写</span></span><br><span class="line">grep -n <span class="comment">'^[^[:alpha:]]' regular_express.txt</span></span><br></pre></td></tr></table></figure></p><blockquote><p> 注意到了吧?那个<code>^</code>符号,在字符集合符号(括号[])之内与之外是不同的! 在 [] 内代表“反<br>向选择”,在[]之外则代表定位在行首的意义!要分清楚喔! </p></blockquote><p>反过来思考,那如果我想要找出<br>来,<strong>行尾</strong>结束为小数点 (.) 的那一行,该如何处理:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="comment">'\.$' regular_express.txt </span></span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="number">1</span>:<span class="string">"Open Source"</span> <span class="keyword">is</span> a good mechanism <span class="keyword">to</span> develop programs.</span><br><span class="line"><span class="number">2</span>:apple <span class="keyword">is</span> my favorite food.</span><br><span class="line"><span class="number">3</span>:Football game <span class="keyword">is</span> <span class="keyword">not</span> use feet only.</span><br><span class="line"><span class="number">4</span>:this dress doesn<span class="comment">'t fit me.</span></span><br><span class="line"><span class="number">10</span>:motorcycle <span class="keyword">is</span> cheap than car.</span><br><span class="line"><span class="number">11</span>:This window <span class="keyword">is</span> clear.</span><br><span class="line"><span class="number">12</span>:the symbol <span class="comment">'*' is represented as start.</span></span><br><span class="line"><span class="number">15</span>:You are the best <span class="keyword">is</span> mean you are the no. <span class="number">1.</span></span><br><span class="line"><span class="number">16</span>:The world &lt;Happy&gt; <span class="keyword">is</span> the same <span class="keyword">with</span> <span class="string">"glad"</span>.</span><br><span class="line"><span class="number">17</span>:I <span class="keyword">like</span> dog.</span><br><span class="line"><span class="number">18</span>:google <span class="keyword">is</span> the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line"><span class="number">20</span>:go! go! <span class="keyword">Let</span><span class="comment">'s go.</span></span><br></pre></td></tr></table></figure></p><blockquote><p> 因为小数点<code>.</code>具有其他意义，所以必须使用转义字符<code>(\)</code>来加以解除其特殊意义！但是第 5~9 行最后面也是 . 啊~怎么无法打 5~9  印出来? 这里就牵涉到 Windows 平台的软件对于断行字符的判断问题了!</p></blockquote><p>我们使用<code>cat -A</code>前十行的倒数六行。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat -An  regular_express.txt| head -n <span class="number">10</span>  | tail -n <span class="number">6</span></span><br><span class="line"># output</span><br><span class="line">    <span class="number">5</span>  However, this dress is about $ <span class="number">3183</span> dollars.^M$</span><br><span class="line">    <span class="number">6</span>  GNU is free air not free beer.^M$</span><br><span class="line">    <span class="number">7</span>  Her hair is very beauty.^M$</span><br><span class="line">    <span class="number">8</span>  I can't finish the test.^M$</span><br><span class="line">    <span class="number">9</span>  Oh! The soup taste good.^M$</span><br><span class="line">   <span class="number">10</span>  motorcycle is cheap than car.$</span><br></pre></td></tr></table></figure></p><blockquote><p>  在上面的输出中我们可以发现5~9行为Windows的断行字符<code>(^M$)</code>,而正常的Linux应该仅有第10行显示的那样<code>($)</code>。所以,那个<code>.</code>自然就不是紧接在<code>$</code>之前喔!也就捉不到5~9 行了!这样可以了解^与$的意义了吧。</p></blockquote><p>如果我想找出哪一行是空白行，也就是该行没有输入任何数据，如何操作？<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> -n <span class="string">'^$'</span> regular_express.txt </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">22</span>:</span><br></pre></td></tr></table></figure></p><blockquote><p> 因为只有行首和行尾<code>(^$)</code>，所以这样就可以找出空白行啦。</p></blockquote><p>再来,假设你已经知道在一个程序脚本 (shell script) 或者是配置文件当中,空白行与开头为 # 的那一行是注解,因此如果你要将数据列出给别人参考时,可以将这些数据省略掉以节省保贵的纸张,那么你可以怎么做呢? 我们以 /etc/rsyslog.conf 这个文件来作范例,你可以自行参考一下输出的结果:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cat</span> -n /etc/rsyslog.conf</span><br><span class="line"><span class="comment"># 在ubuntu 17.10中，输出了60行，很多空白行与#开头的注解行</span></span><br><span class="line"></span><br><span class="line">grep -v <span class="string">'^$'</span> /etc/rsyslog.conf | grep -v -n <span class="string">'^#'</span></span><br><span class="line"><span class="comment"># 结果仅有13行，其中第一个`-v '^$'` 代表不要空行</span></span><br><span class="line"><span class="comment"># 第二个“-v '^#'”， 代表不要开头是#的那行</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">10</span>:module(load=<span class="string">"imuxsock"</span>) <span class="comment"># provides support for local system logging</span></span><br><span class="line"><span class="number">19</span>:module(load=<span class="string">"imklog"</span> permitnonkernelfacility=<span class="string">"on"</span>)</span><br><span class="line"><span class="number">27</span>:<span class="variable">$ActionFileDefaultTemplate</span> RSYSLOG_TraditionalFileFormat</span><br><span class="line"><span class="number">29</span>:<span class="variable">$RepeatedMsgReduction</span> <span class="literal">on</span></span><br><span class="line"><span class="number">33</span>:<span class="variable">$FileOwner</span> syslog</span><br><span class="line"><span class="number">34</span>:<span class="variable">$FileGroup</span> adm</span><br><span class="line"><span class="number">35</span>:<span class="variable">$FileCreateMode</span> <span class="number">0640</span></span><br><span class="line"><span class="number">36</span>:<span class="variable">$DirCreateMode</span> <span class="number">0755</span></span><br><span class="line"><span class="number">37</span>:<span class="variable">$Umask</span> <span class="number">0022</span></span><br><span class="line"><span class="number">38</span>:<span class="variable">$PrivDropToUser</span> syslog</span><br><span class="line"><span class="number">39</span>:<span class="variable">$PrivDropToGroup</span> syslog</span><br><span class="line"><span class="number">43</span>:<span class="variable">$WorkDirectory</span> /var/spool/rsyslog</span><br><span class="line"><span class="number">47</span>:<span class="variable">$IncludeConfig</span> /etc/rsyslog.d/<span class="regexp">*.conf</span></span><br></pre></td></tr></table></figure></p><ul><li>例题四、任意一个字符<code>.</code>与重复字符<code>*</code><br>我们知道通配符<code>*</code>可以用来代表任意（0或多个）字符，但是正则表达式并不是通用字符，两者之间是不同的！至于正则表达式中的<code>.</code>则代表“绝对有一个任意字符”的意思！这两个符号在正则表达式的意义如下：<blockquote><p> <code>.</code>(小数点)：代表“一定有<strong>一个</strong>任意字符”的意思</p><p> <code>*</code>(星号)：代表“<strong>重复前一个字符</strong>，0到无穷多次”的意思，为组合形态</p></blockquote></li></ul><p>这样讲不好懂,我们直接做个练习吧!假设我需要找出 g??d 的字串,亦即共有四个字符,起头是 g 而结束是 d ,我可以这样做:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">'g..d'</span> regular_express.txt </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">1</span>:<span class="string">"Open Source"</span> is <span class="keyword">a</span> good mechanism <span class="built_in">to</span> develop programs.</span><br><span class="line"><span class="number">9</span>:Oh! The soup taste good.</span><br><span class="line"><span class="number">16</span>:The world &lt;Happy&gt; is <span class="keyword">the</span> same <span class="keyword">with</span> <span class="string">"glad"</span>.</span><br></pre></td></tr></table></figure></p><p>再来,如果我想要列出有 oo, ooo, oooo 等等的数据, 也就是说,至少要有两个(含)o以上,该如何是好?是 o 还是 oo 还是 ooo* 呢? 虽然你可以试看看结果, 不过结果太占版面了。</p><p>因为<code>*</code>代表的是<strong>重复 0 个或多个前面的 RE 字符</strong>”的意义, 因此,<strong><code>o*</code>代表的是具有空字符或一个o以上的字符</strong>, 特别注意,因为允许空字符(就是有没有字符都可以的意思),因<br>此,<code>grep -n &#39;o*&#39; regular_express.txt</code>将会把所有的数据都打印出来屏幕上!</p><p>那如果是<code>oo*</code>呢?则第一个o肯定必须要存在,第二个o则是可有可无的多个o, 所以,凡<br>是含有o,oo,ooo,oooo等等,都可以被列出来~</p><p>同理,当我们需要至少两个o以上的字串时,就需要<code>ooo*</code>,亦即是:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">'ooo*'</span> regular_express.txt </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">1</span><span class="symbol">:<span class="string">"Open Source"</span></span> is a good mechanism to develop programs.</span><br><span class="line"><span class="number">2</span><span class="symbol">:apple</span> is my favorite food.</span><br><span class="line"><span class="number">3</span><span class="symbol">:Football</span> game is <span class="keyword">not</span> <span class="keyword">use</span> feet only.</span><br><span class="line"><span class="number">9</span><span class="symbol">:Oh!</span> The soup taste good.</span><br><span class="line"><span class="number">18</span><span class="symbol">:google</span> is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line"><span class="number">19</span><span class="symbol">:goooooogle</span> yes!</span><br></pre></td></tr></table></figure></p><p>如果我们想要字符串开头和结尾都是g,但是两个g之间仅能存在至少一个o，亦即是<code>gog,goog,gooog..</code>等等，那该如何？<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">'g.*g'</span> regular_express.txt </span><br><span class="line"><span class="meta"># . 代表任意一个字符</span></span><br><span class="line"><span class="meta"># .*代表任意个字符</span></span><br></pre></td></tr></table></figure></p><p>如果我想找出含’任意数字‘的行列呢，所以就成为：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep -n '[<span class="string">0-9</span>][<span class="symbol">0-9</span>]*' regular_express.txt </span><br><span class="line"><span class="section"># output</span></span><br><span class="line">5:However, this dress is about $ 3183 dollars.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br></pre></td></tr></table></figure></p><ul><li>例题五、限定连续RE字符范围</li></ul><p>在上个例题当中,我们可以利用 . 与 RE 字符及 * 来设置 0 个到无限多个重复字符, 那如果<br>我想要限制一个范围区间内的重复字符数呢?举例来说,我想要找出两个到五个 o 的连续字<br>串,该如何做?这时候就得要使用到限定范围的字符 {} 了。 但因为 { 与 } 的符号在 shell 是有<br>特殊意义的,因此, 我们必须要使用转义字符 \ 来让他失去特殊意义才行。 至于 {} 的语法是<br>这样的,假设我要找到两个 o 的字串,可以是:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">'o\&#123;2\&#125;'</span> regular_express.txt </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">1</span><span class="symbol">:<span class="string">"Open Source"</span></span> is a good mechanism to develop programs.</span><br><span class="line"><span class="number">2</span><span class="symbol">:apple</span> is my favorite food.</span><br><span class="line"><span class="number">3</span><span class="symbol">:Football</span> game is <span class="keyword">not</span> <span class="keyword">use</span> feet only.</span><br><span class="line"><span class="number">9</span><span class="symbol">:Oh!</span> The soup taste good.</span><br><span class="line"><span class="number">18</span><span class="symbol">:google</span> is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line"><span class="number">19</span><span class="symbol">:goooooogle</span> yes!</span><br><span class="line"></span><br><span class="line">grep -n <span class="string">'go\&#123;2,5\&#125;g'</span> regular_express.txt </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">18</span><span class="symbol">:google</span> is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有了第19行，因为它有6个o</span></span><br></pre></td></tr></table></figure></p><h4 id="3-2-4、-基础正则表达式字符汇整-characters"><a href="#3-2-4、-基础正则表达式字符汇整-characters" class="headerlink" title="3.2.4、 基础正则表达式字符汇整(characters)"></a>3.2.4、 基础正则表达式字符汇整(characters)</h4><p>经过上面的几个简单的练习，我们可以将基础的正则表达式特殊字符汇整如下表：</p><p><img src="https://wx3.sinaimg.cn/mw1024/e0db46edgy1fq7ngc14chj20xj163nbj.jpg" align="center"></p><blockquote><p> <strong>正则表达式的特殊字符”与一般在命令行输入指令的“万用字符”并不相同</strong>。<br> 例如。在万用字符当中的 代表的是“ 0 ~ 无限多个字符”的意思,但是在正则表达式当中, 则是“重复0到无穷多个的前一个 RE 字符”的意思~使用的意义并不相同,不要搞混了!</p></blockquote><p>举例来说,不支持正则表达式的 ls 这个工具中,若我们使用 “ls -l ” 代表的是任意文件名的文<br>件,而 “ls -l a ”代表的是以 a 为开头的任何文件名的文件, 但在正则表达式中,我们要找到<br>含有以 a 为开头的文件,则必须要这样:(需搭配支持正则表达式的工具)</p><pre><code>ls | grep -n &apos;^a.*&apos;</code></pre><p>要想以<code>ls -l</code>配合grep找出<code>/etc/</code>下面文件类型为链接文件属性的文件名，该如何做呢？由于<code>ls -l</code>列出链接文件时标头会是<code>lrwxrwxrwx</code>,因此使用如下的指令即可找出结果：</p><pre><code>ls -l /etc \grep &apos;^l&apos;# 若仅想列出几个文件，再以`| wc -l`来累加处理即可。</code></pre><h4 id="3-2-5、-sed工具"><a href="#3-2-5、-sed工具" class="headerlink" title="3.2.5、 sed工具"></a>3.2.5、 sed工具</h4><p>在了解了一些正则表达式的基础应用之后,再来呢?呵呵~两个东西可以玩一玩的,那就是<br>sed 跟下面会介绍的 awk 了! 这两个家伙可是相当的有用的啊!</p><p>我们先来谈一谈 sed 好了, sed 本身也是一个管线命令,可以分析 standard input 的啦! 而<br>且 sed 还可以将数据进行取代、删除、新增、撷取特定行等等的功能呢!很不错吧~ 我们先<br>来了解一下 sed 的用法,再来聊他的用途好了!</p><p><img src="https://wx1.sinaimg.cn/mw1024/e0db46edgy1fq7o1zepd6j20zc0gmtem.jpg" align="center"></p><ul><li>以行为单位的新增/删除功能</li></ul><p>sed光是用看的，是看不懂的啦！，又要开始练习了</p><p><b><span style="color: red">范例一：</span></b>将<code>/etc/passwd</code>的内容拷贝<code>pd.txt</code>列出并且打印行号，同时，请将第2-5行删除！<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nl pd.txt  | sed <span class="string">'2,5d'</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">     <span class="number">1</span>  <span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line">     <span class="number">6</span>  <span class="symbol">games:</span><span class="symbol">x:</span><span class="number">5</span><span class="symbol">:</span><span class="number">60</span><span class="symbol">:games</span><span class="symbol">:/usr/games</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">     <span class="number">7</span>  <span class="symbol">man:</span><span class="symbol">x:</span><span class="number">6</span><span class="symbol">:</span><span class="number">12</span><span class="symbol">:man</span><span class="symbol">:/var/cache/man</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">     <span class="number">8</span>  <span class="symbol">lp:</span><span class="symbol">x:</span><span class="number">7</span><span class="symbol">:</span><span class="number">7</span><span class="symbol">:lp</span><span class="symbol">:/var/spool/lpd</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">    ...........后面省略................</span><br></pre></td></tr></table></figure></p><blockquote><p> 看到了吧?sed 的动作为 ‘2,5d’ ,那个 d 就是删除!因为 2-5 行给他删除了,所以显示的数据<br>就没有 2-5 行啰~ 另外,注意一下,原本应该是要下达 sed -e 才对,没有 -e 也行啦!同时<br>也要注意的是, sed 后面接的动作,请务必以 ‘’ 两个单引号括住喔!</p></blockquote><p>如果只删除第2行，可以使用<code>nl pd.txt | sed &#39;2d&#39;</code>来实现，若要删除第3到最后一行，则可以使用<code>nl pd.txt |sed &#39;3,$d&#39;</code>,其中<code>$</code>代表最后一行！</p><p><b><span style="color: red">范例二：</span></b>承上题，在第二行后（亦即是加在第三行）加上“drink tea?”字样！<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nl pd.txt | sed <span class="string">'2a drink tea?'</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">     <span class="number">1</span>  <span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line">     <span class="number">2</span>  <span class="symbol">daemon:</span><span class="symbol">x:</span><span class="number">1</span><span class="symbol">:</span><span class="number">1</span><span class="symbol">:daemon</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">drink tea?</span><br><span class="line">     <span class="number">3</span>  <span class="symbol">bin:</span><span class="symbol">x:</span><span class="number">2</span><span class="symbol">:</span><span class="number">2</span><span class="symbol">:bin</span><span class="symbol">:/bin</span><span class="symbol">:/usr/sbin/nologin</span></span><br></pre></td></tr></table></figure></p><p>嘿嘿!在 a 后面加上的字串就已将出现在第二行后面啰!那如果是要在第二行前呢?<code>nlpd.txt | sed &#39;2i drink tea&#39;</code>就对啦!就是将“ a ”变成“ i ”即可。 增加一行很简单,那如果<br>是要增将两行以上呢?</p><p><b><span style="color: red">范例三：</span></b>在第二行后面加入两行字，例如“drink tea or …”与”drink beer”字样！<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nl pd.txt | sed <span class="string">'2a drink tea or ... \</span></span><br><span class="line"><span class="string"> &gt; drink beer?'</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">     <span class="number">1</span>  <span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line">     <span class="number">2</span>  <span class="symbol">daemon:</span><span class="symbol">x:</span><span class="number">1</span><span class="symbol">:</span><span class="number">1</span><span class="symbol">:daemon</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">drink tea <span class="keyword">or</span> ... </span><br><span class="line">drink beer?</span><br><span class="line">     <span class="number">3</span>  <span class="symbol">bin:</span><span class="symbol">x:</span><span class="number">2</span><span class="symbol">:</span><span class="number">2</span><span class="symbol">:bin</span><span class="symbol">:/bin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">.............后面省略........</span><br></pre></td></tr></table></figure></p><blockquote><p> 这个范例的重点是“我们可以新增不只一行喔!可以新增好几行”但是每一行之间都必须要以反<br>斜线“ \ ”来进行新行的增加喔!所以,上面的例子中,我们可以发现在第一行的最后面就有 \<br>存在啦!在多行新增的情况下, \ 是一定要的喔!</p></blockquote><ul><li>以行为单位的取代与显示功能</li></ul><p>刚刚只是介绍了如何新增与删除，那么如果要整行取代呢？</p><p><b><span style="color: red">范例四：</span></b>我想将第2-5行的内容取代成为”No 2-5 number”呢？<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nl pd.txt | sed <span class="string">'2,5c No 2-5 number'</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">     <span class="number">1</span>  <span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line">No <span class="number">2</span>-<span class="number">5</span> number</span><br><span class="line">     <span class="number">6</span>  <span class="symbol">games:</span><span class="symbol">x:</span><span class="number">5</span><span class="symbol">:</span><span class="number">60</span><span class="symbol">:games</span><span class="symbol">:/usr/games</span><span class="symbol">:/usr/sbin/nologin</span></span><br></pre></td></tr></table></figure></p><p>通过这个方法我们就能够将数据整行取代了!非常容易吧!sed 还有更好用的东东!我们以前<br>想要列出第 11~20 行, 得要通过<code>head -n 20 | tail -n 10</code>之类的方法来处理,很麻烦啦~ sed<br>则可以简单的直接取出你想要的那几行!是通过行号来捉的喔!看看下面的范例先:</p><p><b><span style="color: red">范例五：</span></b>仅列出<code>pd.txt</code>文件内的第5-7行<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nl pd.txt | sed -n <span class="string">'5,7p'</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">     <span class="number">5</span>  <span class="symbol">sync:</span><span class="symbol">x:</span><span class="number">4</span><span class="symbol">:</span><span class="number">65534</span><span class="symbol">:sync</span><span class="symbol">:/bin</span><span class="symbol">:/bin/sync</span></span><br><span class="line">     <span class="number">6</span>  <span class="symbol">games:</span><span class="symbol">x:</span><span class="number">5</span><span class="symbol">:</span><span class="number">60</span><span class="symbol">:games</span><span class="symbol">:/usr/games</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">     <span class="number">7</span>  <span class="symbol">man:</span><span class="symbol">x:</span><span class="number">6</span><span class="symbol">:</span><span class="number">12</span><span class="symbol">:man</span><span class="symbol">:/var/cache/man</span><span class="symbol">:/usr/sbin/nologin</span></span><br></pre></td></tr></table></figure></p><blockquote><p> 上述的指令中有个重要的选项<code></code>-n<code>,按照说明文档,这个 -n 代表的是“安静模式”! 那么为什么要使用安静模式呢?你可以自行下达</code>sed ‘5,7p’` 就知道了 (5-7 行会重复输出)! 有没有<br>加上 -n 的参数时,输出的数据可是差很多的喔!你可以通过这个 sed 的以行为单位的显示功<br>能, 就能够将某一个文件内的某些行号捉出来查阅!很棒的功能!不是吗?</p></blockquote><ul><li>部分数据的搜寻并取代的功能</li></ul><p>除了整行的处理模式之外，sed还可以用行为单位进行部分数据的查找并替换的功能，基本上sed的查找与替换与vi类似！</p><pre><code>sed &apos;s/要被取代的字串/新的字串/g&apos;</code></pre><p>上表中特殊字体的部分为关键字,请记下来!至于三个斜线分成两栏就是新旧字串的替换<br>啦。我们使用下面这个取得IP数据的范例,一段一段的来处理,让你了解一下什么是咱们所谓的查找并替换吧!<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># step1 : 先观察源信息，利用<span class="string">`sbin/ifconfig`</span> 查询<span class="built_in">IP</span></span><br><span class="line">    /sbin/ifconfig enp3s0</span><br><span class="line">    # output</span><br><span class="line"><span class="symbol">    enp3s0:</span> flags=<span class="number">4163</span>&lt;<span class="meta">UP</span>,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">            inet <span class="number">219.223</span><span class="meta">.243</span><span class="meta">.131</span>  netmask <span class="number">255.255</span><span class="meta">.248</span><span class="meta">.0</span>  broadcast <span class="number">219.223</span><span class="meta">.247</span><span class="meta">.255</span></span><br><span class="line">            inet6 fe80::<span class="number">1234</span>:4cee:444b:1d66  prefixlen <span class="number">64</span>  scopeid <span class="number">0x20</span>&lt;link&gt;</span><br><span class="line">            inet6 <span class="number">2001</span>:<span class="number">250</span>:3c02:<span class="number">301</span>:c9a3:6a1d:d5ce:ec5f  prefixlen <span class="number">128</span>  scopeid <span class="number">0x0</span>&lt;<span class="meta">global</span>&gt;</span><br><span class="line">    # 重点在第二行，也就是<span class="built_in">ip</span>地址那一行</span><br><span class="line"></span><br><span class="line"># step2 :利用关键字配合grep选取出关键的一行数据</span><br><span class="line">    ifconfig enp3s0 | grep <span class="string">'inet '</span></span><br><span class="line">    # output</span><br><span class="line">        inet <span class="number">219.223</span><span class="meta">.243</span><span class="meta">.131</span>  netmask <span class="number">255.255</span><span class="meta">.248</span><span class="meta">.0</span>  broadcast <span class="number">219.223</span><span class="meta">.247</span><span class="meta">.255</span></span><br><span class="line"></span><br><span class="line"># step3：将<span class="built_in">IP</span>前面的部分予以删除</span><br><span class="line">     ifconfig enp3s0 | grep <span class="string">'inet '</span> | sed <span class="string">'s/^.*inet //g'</span></span><br><span class="line">     # output</span><br><span class="line">        <span class="number">219.223</span><span class="meta">.243</span><span class="meta">.131</span>  netmask <span class="number">255.255</span><span class="meta">.248</span><span class="meta">.0</span>  broadcast <span class="number">219.223</span><span class="meta">.247</span><span class="meta">.255</span></span><br><span class="line"></span><br><span class="line"># step4：将<span class="built_in">IP</span>后面的部分删除</span><br><span class="line">    ifconfig enp3s0 | grep <span class="string">'inet '</span> | sed <span class="string">'s/^.*inet//g'</span> | sed <span class="string">'s/ netmask.*$//g'</span></span><br><span class="line">    # output</span><br><span class="line">        <span class="number">219.223</span><span class="meta">.243</span><span class="meta">.131</span></span><br></pre></td></tr></table></figure></p><blockquote><p> 通过这个范例的练习也建议您依据此一步骤来研究你的指令!就是先观察,然后再一层一层<br>的试做, 如果有做不对的地方,就先予以修改,改完之后测试,成功后再往下继续测试。</p></blockquote><ul><li>直接修改文件内容（<b><span style="color: red">危险动作</span></b>）</li></ul><p>你以为 sed 只有这样的能耐吗?那可不! sed 甚至可以直接修改文件的内容呢!而不必使用<br>管线命令或数据流重导向! 不过,由于这个动作会直接修改到原始的文件,所以请你千万不<br>要随便拿系统配置文件来测试喔! 我们还是使用你下载的 regular_express.txt 文件来测试看<br>看吧!</p><p><b><span style="color: red">范例六：</span></b>利用sed将<code>regular_express.txt</code>内每一行结尾若为<code>.</code>则换成<code>！</code>。<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="comment">'s/\.$/\!/g' regular_express.txt </span></span><br><span class="line">cat regular_express.txt </span><br><span class="line"><span class="meta"># output</span></span><br><span class="line"><span class="string">"Open Source"</span> <span class="keyword">is</span> a good mechanism <span class="keyword">to</span> develop programs!</span><br><span class="line">apple <span class="keyword">is</span> my favorite food!</span><br><span class="line">Football game <span class="keyword">is</span> <span class="keyword">not</span> use feet only!</span><br><span class="line">this dress doesn<span class="comment">'t fit me!</span></span><br><span class="line">However, this dress <span class="keyword">is</span> about $ <span class="number">3183</span> dollars.</span><br><span class="line">GNU <span class="keyword">is</span> free air <span class="keyword">not</span> free beer.</span><br><span class="line">Her hair <span class="keyword">is</span> very beauty.</span><br><span class="line">I can<span class="comment">'t finish the test.</span></span><br><span class="line">Oh! The soup taste good.</span><br><span class="line">motorcycle <span class="keyword">is</span> cheap than car!</span><br><span class="line">This window <span class="keyword">is</span> clear!</span><br><span class="line">the symbol <span class="comment">'*' is represented as start!</span></span><br><span class="line">Oh! My god!</span><br><span class="line">The gd software <span class="keyword">is</span> a library <span class="keyword">for</span> drafting programs.</span><br><span class="line">You are the best <span class="keyword">is</span> mean you are the no. <span class="number">1</span>!</span><br><span class="line">The world &lt;Happy&gt; <span class="keyword">is</span> the same <span class="keyword">with</span> <span class="string">"glad"</span>!</span><br><span class="line">I <span class="keyword">like</span> dog!</span><br><span class="line">google <span class="keyword">is</span> the best tools <span class="keyword">for</span> search keyword!</span><br><span class="line">goooooogle yes!</span><br><span class="line">go! go! <span class="keyword">Let</span><span class="comment">'s go!</span></span><br><span class="line"><span class="meta"># I am VBird</span></span><br></pre></td></tr></table></figure></p><p><b><span style="color: red">范例七：</span></b>利用sed直接在<code>regular_express.txt</code>最后一行加入<code># This is a test</code><br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sed -i '$a <span class="comment"># This is a test' regular_express.txt</span></span><br><span class="line">nl regular_express.txt| sed -n '20,25p'</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">   <span class="number"> 20 </span> go! go! Let's go!</span><br><span class="line">   <span class="number"> 21 </span> <span class="comment"># I am VBird</span></span><br><span class="line">       </span><br><span class="line">   <span class="number"> 22 </span> <span class="comment"># This is a test</span></span><br></pre></td></tr></table></figure></p><blockquote><p> sed 的“ -i ”选项可以直接修改文件内容,这功能非常有帮助!举例来说,如果你有一个 100 万<br>行的文件,你要在第 100 行加某些文字,此时使用 vim 可能会疯掉!因为文件太大了!那怎<br>办?就利用 sed 啊!通过 sed 直接修改/取代的功能,你甚至不需要使用 vim 去修订!很棒<br>吧!</p></blockquote><h3 id="3-3、-扩展正则表达式"><a href="#3-3、-扩展正则表达式" class="headerlink" title="3.3、 扩展正则表达式"></a>3.3、 扩展正则表达式</h3><p>事实上,一般读者只要了解基础型的正则表达式大概就已经相当足够了,不过,某些时刻为<br>了要简化整个指令操作, 了解一下使用范围更广的延伸型正则表达式的表示式会更方便呢!<br>举个简单的例子好了,在上节的例题三的最后一个例子中,我们要去除空白行与行首为 # 的<br>行列,使用的是</p><pre><code>grep -v &apos;^$&apos; regular_express.txt | grep -v &apos;^#&apos;</code></pre><p>需要使用到管线命令来搜寻两次！那么如果使用延伸型的正则表达式，我们可以简化为：</p><pre><code>egrep -v &apos;^$|^#&apos; regular_express.txt</code></pre><blockquote><p> 延伸型正则表达式可以通过群组功能“ | ”来进行一次搜寻!那个在单引号内的管线意义为“或<br>or”啦! 是否变的更简单呢?此外,grep 默认仅支持基础正则表达式,如果要使用延伸型正则<br>表达式,你可以使用 grep -E , 不过更建议直接使用 egrep !直接区分指令比较好记忆!其<br>实 egrep 与 grep -E 是类似命令别名的关系。</p></blockquote><p>熟悉了正则表达式之后,到这个延伸型的正则表达式,你应该也会想到,不就是多几个重要<br>的特殊符号吗?  是的~所以,我们就直接来说明一下,延伸型正则表达式的特殊符如下表所示：</p><p><img src="https://wx2.sinaimg.cn/mw1024/e0db46edgy1fq7wpghpsdj20ue0jdjxc.jpg" align="center"></p><p><strong>例子测试结果如下图所示：</strong></p><p><img src="https://wx2.sinaimg.cn/mw1024/e0db46edgy1fq7wx5abqmj20mz0aljti.jpg" align="center"></p><blockquote><p> <code>!</code>不是特殊字符，如果想要查出来文件中含有！与&gt;的字行时，可以这样操作：<br>     grep -n ‘[!&gt;]’ regular_express.txt</p></blockquote><h3 id="3-4、-文件的格式化与相关处理"><a href="#3-4、-文件的格式化与相关处理" class="headerlink" title="3.4、 文件的格式化与相关处理"></a>3.4、 文件的格式化与相关处理</h3><p>接下来让我们来将文件进行一些简单的编排吧!下面这些动作可以将你的讯息进行排版的动<br>作, 不需要重新以 vim 去编辑,通过数据流重导向配合下面介绍的 printf 功能,以及 awk 指<br>令, 就可以让你的讯息以你想要的模样来输出了!试看看吧!</p><h4 id="3-4-1、-格式化打印：printf"><a href="#3-4-1、-格式化打印：printf" class="headerlink" title="3.4.1、 格式化打印：printf"></a>3.4.1、 格式化打印：printf</h4><p><img src="https://wx1.sinaimg.cn/mw690/e0db46edgy1fq7x8zjkhij20j908c75p.jpg" align="center"></p><h4 id="3-4-2、-awk：好用的数据处理工具"><a href="#3-4-2、-awk：好用的数据处理工具" class="headerlink" title="3.4.2、 awk：好用的数据处理工具"></a>3.4.2、 <code>awk</code>：好用的数据处理工具</h4><p>awk 也是一个非常棒的数据处理工具!相较于 sed 常常作用于一整个行的处理, awk 则比较<br>倾向于一行当中分成数个“字段”来处理。因此,awk 相当的适合处理小型的数据数据处理!<code>awk</code> 通常运行的模式是这样的:</p><pre><code>awk &apos;条件类型1{动作1} 条件类型2{动作2} .... &apos; filename</code></pre><p>awk 后面接两个单引号并加上大括号 {} 来设置想要对数据进行的处理动作。 awk 可以处理后<br>续接的文件,也可以读取来自前个指令的 standard output 。 但如前面说的, awk 主要是处<br>理“每一行的字段内的数据”,而默认的“字段的分隔符号为 “空白键” 或 “[tab]键” ”!举例来说,<br>我们用 last 可以将登陆者的数据取出来,结果如下所示:（下面命令是在我购买的远程主机上进行的）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">last -n 5</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">root     pts/1        58.60.1.102      Tue Apr 10 22:29   still logged <span class="keyword">in</span>   </span><br><span class="line">root     pts/0        58.60.1.76       Tue Apr 10 22:21   still logged <span class="keyword">in</span>   </span><br><span class="line">root     pts/0        58.60.1.76       Sun Apr  8 20:58 - 21:36  (00:37)    </span><br><span class="line">root     pts/0        58.60.1.76       Fri Mar 23 08:19 - 08:19  (00:00)    </span><br><span class="line">reboot  <span class="built_in"> system </span>boot  4.13.9-1.el6.elr Tue Jan 23 22:26 - 22:30 (76+23:03)</span><br></pre></td></tr></table></figure><p>若我想取出帐号与登录者的IP，且帐号与IP之间一<code>[Tab]</code>隔开，可以进行如下操作：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">last -n <span class="number">5</span> | awk '&#123;print $<span class="number">1</span> <span class="string">"<span class="subst">\t</span>"</span> $<span class="number">3</span>&#125;'</span><br><span class="line"># output</span><br><span class="line">root    <span class="number">58.60</span><span class="number">.1</span><span class="number">.102</span></span><br><span class="line">root    <span class="number">58.60</span><span class="number">.1</span><span class="number">.76</span></span><br><span class="line">root    <span class="number">58.60</span><span class="number">.1</span><span class="number">.76</span></span><br><span class="line">root    <span class="number">58.60</span><span class="number">.1</span><span class="number">.76</span></span><br><span class="line">reboot  boot</span><br></pre></td></tr></table></figure></p><p>上表是 awk 最常使用的动作!通过 print 的功能将字段数据列出来!字段的分隔则以空白键或<br>[tab] 按键来隔开。 因为不论哪一行我都要处理,因此,就不需要有 “条件类型” 的限制!我所<br>想要的是第一栏以及第三栏, 但是,第五行的内容怪怪的~这是因为数据格式的问题啊!所以~使用 awk 的时候,请先确认一下你的数据当中,如果是连续性的数据,请不要有空格或 [tab]在内,否则,就会像这个例子这样,会发生误判!</p><p>另外,由上面这个例子你也会知道,在awk的括号内,每一行的每个字段都是有变量名称<br>的,那就是 $1, $2… 等变量名称。以上面的例子来说, <code>root</code>是$1,因为他是第一栏!<br>至于<code>58.60.1.102</code>是第三栏, 所以他就是<code>$3</code>!后面以此类推~呵呵!还有个变量!那<br>就是 $0 ,$0 代表“一整列数据”的意思~以上面的例子来说,第一行的 $0 代表的就是一整行数据的意思。 由此可知,刚刚上面五行当中,整个 awk 的处理流程是:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">step1：读入第一行，并将第一行的数据填入 $<span class="number">0</span>, $<span class="number">1</span>, $<span class="number">2.</span>... 等变量当中;</span><br><span class="line">step2：依据”条件类型“的限制，判断是否需要进行后面的”动作“;</span><br><span class="line">step3：做完所有的动作与条件类型</span><br><span class="line">step4：若还有后续的‘行’的数据，则重复上面<span class="number">1</span><span class="number">-3</span>的步骤，知道所有的数据都读完为止。</span><br></pre></td></tr></table></figure></p><p>经过这样的步骤,你会晓得, awk 是“以行为一次处理的单位”, 而“以字段为最小的处理单<br>位”。好了,那么 awk 怎么知道我到底这个数据有几行?有几栏呢?这就需要 awk 的内置变<br>量的帮忙啦~</p><table><thead><tr><th style="text-align:left">变量名称</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:left">NF</td><td style="text-align:center">每一行($0)拥有的字段总数</td></tr><tr><td style="text-align:left">NR</td><td style="text-align:center">目前awk所处理的是“第几行”数据</td></tr><tr><td style="text-align:left">FS</td><td style="text-align:center">目前的分隔字符，默认是空白键</td></tr></tbody></table><blockquote><p> 继续上面的例子，如果我想实现以下效果：<br><br>   &emsp;列出每一行的帐号(就是 $1);<br><br>   &emsp;列出目前处理的行数(就是 awk 内的 NR 变量)<br><br>   &emsp;并且说明,该行有多少字段(就是 awk 内的 NF 变量)</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">last</span> -n <span class="number">5</span> | awk <span class="string">'&#123;print $1 "\t lines: " NR "\t columns: " NF&#125;'</span></span><br><span class="line"># output</span><br><span class="line">root     <span class="built_in">line</span><span class="variable">s:</span> <span class="number">1</span>    column<span class="variable">s:</span> <span class="number">10</span></span><br><span class="line">root     <span class="built_in">line</span><span class="variable">s:</span> <span class="number">2</span>    column<span class="variable">s:</span> <span class="number">10</span></span><br><span class="line">root     <span class="built_in">line</span><span class="variable">s:</span> <span class="number">3</span>    column<span class="variable">s:</span> <span class="number">10</span></span><br><span class="line">root     <span class="built_in">line</span><span class="variable">s:</span> <span class="number">4</span>    column<span class="variable">s:</span> <span class="number">10</span></span><br><span class="line">reboot   <span class="built_in">line</span><span class="variable">s:</span> <span class="number">5</span>    column<span class="variable">s:</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><ul><li><code>awk</code>的逻辑运算字符</li></ul><p>既然有需要用到“条件”的类别，自然就需要一些逻辑运算咯～例如下面这些，如下表所示：</p><table><thead><tr><th style="text-align:center">运算单元</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不等于</td></tr></tbody></table><p>好了,我们实际来运用一下逻辑判断吧!举例来说,在 <code>pd.txt</code> 当中是以冒号 “:” 来作为<br>字段的分隔, 该文件中第一字段为帐号,第三字段则是 UID。那假设我要查阅,第三栏小于<br>10 以下的数据,并且仅列出帐号与第三栏, 那么可以这样做:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat pd.txt  | \</span><br><span class="line">&gt; awk <span class="string">'&#123;FS=":"&#125; $3 &lt; 10 &#123;print $1 "\t" $3&#125;'</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span> </span><br><span class="line">daemon  <span class="number">1</span></span><br><span class="line">bin <span class="number">2</span></span><br><span class="line">sys <span class="number">3</span></span><br><span class="line">sync    <span class="number">4</span></span><br><span class="line">games   <span class="number">5</span></span><br><span class="line">man <span class="number">6</span></span><br><span class="line">lp  <span class="number">7</span></span><br><span class="line">mail    <span class="number">8</span></span><br><span class="line">news    <span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>有趣吧!不过,怎么第一行没有正确的显示出来呢?这是因为我们读入第一行的时候,那些<br>变量 $1, $2… 默认还是以空白键为分隔的,所以虽然我们定义了 FS=”:” 了, 但是却仅能在第<br>二行后才开始生效。那么怎么办呢?我们可以预先设置 awk 的变量啊! 利用 BEGIN 这个关<br>键字喔!这样做:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat pd.txt | \</span><br><span class="line">&gt; awk 'BEGIN &#123;FS=<span class="string">":"</span>&#125; $<span class="number">3</span> &lt; <span class="number">10</span> &#123;print $<span class="number">1</span> <span class="string">"<span class="subst">\t</span>"</span> $<span class="number">3</span>&#125;'</span><br><span class="line"># output</span><br><span class="line">root    <span class="number">0</span></span><br><span class="line">daemon  <span class="number">1</span></span><br><span class="line">bin     <span class="number">2</span></span><br><span class="line">sys     <span class="number">3</span></span><br><span class="line">sync    <span class="number">4</span></span><br><span class="line">games   <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>我有一个薪资数据表文件名为<code>pay.txt</code>，内容是这样的：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name    <span class="number">1</span>st     <span class="number">2</span>nd     <span class="number">3</span>th</span><br><span class="line">Vd      <span class="number">23000</span>   <span class="number">24000</span>   <span class="number">25000</span></span><br><span class="line">Di      <span class="number">21000</span>   <span class="number">20000</span>   <span class="number">23000</span></span><br><span class="line">Bd      <span class="number">43000</span>   <span class="number">42000</span>   <span class="number">41000</span></span><br></pre></td></tr></table></figure></p><p>如果我想计算每个人的总额呢？而且我还想要格式化输出，我们可以这样考虑：</p><blockquote><p> 第一行只是说明，所以第一行不要进行加总（NR==1时处理）<br><br> 第二行以后就会有加总的情况出现（NR &gt;=2 以后处理 ）</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat pay.txt | \</span><br><span class="line">&gt; awk 'NR == <span class="number">1</span> &#123;printf <span class="string">"%10s %10s %10s %10s %10s<span class="subst">\n</span>"</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>,<span class="string">"Total"</span>&#125;</span><br><span class="line">&gt; NR &gt;= <span class="number">2</span> &#123;Total = $<span class="number">2</span>+$<span class="number">3</span>+$<span class="number">4</span></span><br><span class="line">&gt; printf <span class="string">"%10s %10s %10s %10s %10.2f<span class="subst">\n</span>"</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>,Total&#125;'</span><br><span class="line"># output</span><br><span class="line">      Name        <span class="number">1</span>st        <span class="number">2</span>nd        <span class="number">3</span>th      Total</span><br><span class="line">        Vd      <span class="number">23000</span>      <span class="number">24000</span>      <span class="number">25000</span>   <span class="number">72000.00</span></span><br><span class="line">        Di      <span class="number">21000</span>      <span class="number">20000</span>      <span class="number">23000</span>   <span class="number">64000.00</span></span><br><span class="line">        Bd      <span class="number">43000</span>      <span class="number">42000</span>      <span class="number">41000</span>  <span class="number">126000.00</span></span><br></pre></td></tr></table></figure><p>上面的例子有几个重要事项应该先说明的：</p><ul><li><code>awk</code>的指令间隔:所有awk的动作,亦即在{}内的动作,如果有需要多个指令辅助时,可利用分号“;”间隔, 或者直接以 [Enter] 按键来隔开每个指令,例如上面的范例中我就使用了三次 [enter] 喔!</li><li>逻辑运算当中，如果是<strong>等于</strong>的情况，则务必使用两个等号“==”！</li><li>格式化输出时，在printf的格式设置当中，务必加上<code>\n</code>，才能进行分行</li><li>与bash shell的变量不同，在<code>awk</code>当中，变量可以直接使用，不需加上<code>$</code>符号</li></ul><p>利用 awk 这个玩意儿,就可以帮我们处理很多日常工作了呢!真是好用的很~ 此外, awk<br>的输出格式当中,常常会以 printf 来辅助,所以, 最好你对 printf 也稍微熟悉一下比较好啦!<br>另外, awk 的动作内 {} 也是支持 if (条件) 的喔! 举例来说,上面的指令可以修改成为这<br>样:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat pay.txt | \</span><br><span class="line">&gt; awk '&#123;if (NR==<span class="number">1</span>) printf <span class="string">"%10s %10s %10s %10s %10s<span class="subst">\n</span>"</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>,<span class="string">"Total"</span>&#125;</span><br><span class="line">&gt; NR &gt;= <span class="number">2</span> &#123;Total = $<span class="number">2</span>+$<span class="number">3</span>+$<span class="number">4</span></span><br><span class="line">&gt; printf <span class="string">"%10s %10s %10s %10s %10.2f<span class="subst">\n</span>"</span>,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span>,Total&#125;'</span><br><span class="line"># output</span><br><span class="line">      Name        <span class="number">1</span>st        <span class="number">2</span>nd        <span class="number">3</span>th      Total</span><br><span class="line">        Vd      <span class="number">23000</span>      <span class="number">24000</span>      <span class="number">25000</span>   <span class="number">72000.00</span></span><br><span class="line">        Di      <span class="number">21000</span>      <span class="number">20000</span>      <span class="number">23000</span>   <span class="number">64000.00</span></span><br><span class="line">        Bd      <span class="number">43000</span>      <span class="number">42000</span>      <span class="number">41000</span>  <span class="number">126000.00</span></span><br></pre></td></tr></table></figure></p><h4 id="3-4-3、-文件比较工具"><a href="#3-4-3、-文件比较工具" class="headerlink" title="3.4.3、 文件比较工具"></a>3.4.3、 文件比较工具</h4><p>什么时候会用到文件的比对啊?通常是<strong>同一个软件的不同版本之间,比较配置文件与原始文件的差别</strong>。很多时候所谓的文件比对,通常是用在ASCII纯文本文件的比对上的!那么比对文件的指令有哪些?最常见的就是diff啰!另外,除了diff比对之外,我们还可以借由cmp来比对非纯文本文件!同时,也能够借由 diff 创建的分析档,以处理补丁(patch)功能的文件呢!就来玩玩先!</p><ul><li><b style="color: red">diff</b></li></ul><p><code>diff</code>就是用在比对两个文件之间的差异的,并且是<strong>以行为单位来比对的</strong>!一般是用在ASCII纯文本文件的比对上。由于是以行为比对的单位,因此<strong><code>diff</code>通常是用在同一的文件(或软件)的新旧版本区别上</strong>! 举例来说,假如我们要将<code>/etc/passwd</code>处理成为一个新的版本<code>pd</code>,处理方式为:将第四行删除,第六行则取代成为“no six line”,新的文件放置到 <code>/shell_learning/test</code> 里面,那么应该怎么做?</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd ~<span class="regexp">/Desktop/shell</span>_learning</span><br><span class="line">mkdir test</span><br><span class="line">cp /etc/passwd pd</span><br><span class="line">cat pd | sed -e <span class="string">'4d'</span> -e <span class="string">'6c no six line'</span> &gt; pd.new</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">cat -n pd.new | head -n <span class="number">6</span></span><br><span class="line">     <span class="number">1</span>  <span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line">     <span class="number">2</span>  <span class="symbol">daemon:</span><span class="symbol">x:</span><span class="number">1</span><span class="symbol">:</span><span class="number">1</span><span class="symbol">:daemon</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">     <span class="number">3</span>  <span class="symbol">bin:</span><span class="symbol">x:</span><span class="number">2</span><span class="symbol">:</span><span class="number">2</span><span class="symbol">:bin</span><span class="symbol">:/bin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">     <span class="number">4</span>  <span class="symbol">sync:</span><span class="symbol">x:</span><span class="number">4</span><span class="symbol">:</span><span class="number">65534</span><span class="symbol">:sync</span><span class="symbol">:/bin</span><span class="symbol">:/bin/sync</span></span><br><span class="line">     <span class="number">5</span>  no six line</span><br><span class="line">     <span class="number">6</span>  <span class="symbol">man:</span><span class="symbol">x:</span><span class="number">6</span><span class="symbol">:</span><span class="number">12</span><span class="symbol">:man</span><span class="symbol">:/var/cache/man</span><span class="symbol">:/usr/sbin/nologin</span></span><br></pre></td></tr></table></figure><p>接下来讨论一下关于<code>diff</code>的用法吧！<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff [-bBi] <span class="keyword">from</span>-<span class="built_in">file</span> <span class="keyword">to</span>-<span class="built_in">file</span></span><br><span class="line"><span class="comment"># paras：</span></span><br><span class="line">    <span class="keyword">from</span>-<span class="built_in">file</span> : 一个文件名,作为原始比对文件的文件名;</span><br><span class="line">    <span class="keyword">to</span>-<span class="built_in">file</span> : 一个文件名,作为目的比对文件的文件名;</span><br><span class="line">    注意,<span class="keyword">from</span>-<span class="built_in">file</span> 或 <span class="keyword">to</span>-<span class="built_in">file</span> 可以 - 取代,那个 - 代表“Standard input”之意。</span><br><span class="line">    -b  :忽略一行当中,仅有多个空白的差异(例如 <span class="string">"about me"</span> 与 <span class="string">"about       me"</span> 视为相同</span><br><span class="line">    -B  :忽略空白行的差异。</span><br><span class="line">    -i  :忽略大小写的不同。</span><br></pre></td></tr></table></figure></p><p><span style="color:red"><b>范例一:</b></span>比对<code>pd</code>与<code>pd.new</code>的差异<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff pd pd.new </span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">4</span>d3      &lt;==左边第四行被删除(d)了,基准是右边第三行</span><br><span class="line">&lt; <span class="symbol">sys:</span><span class="symbol">x:</span><span class="number">3</span><span class="symbol">:</span><span class="number">3</span><span class="symbol">:sys</span><span class="symbol">:/dev</span><span class="symbol">:/usr/sbin/nologin</span>   &lt;===这边列出左边(&lt;)文件被删除的那一行内容</span><br><span class="line"><span class="number">6</span>c5      &lt;==左边文件的第六行被替换(c)成右边文件的第五行</span><br><span class="line">&lt; <span class="symbol">games:</span><span class="symbol">x:</span><span class="number">5</span><span class="symbol">:</span><span class="number">60</span><span class="symbol">:games</span><span class="symbol">:/usr/games</span><span class="symbol">:/usr/sbin/nologin</span>   &lt;===左边(&lt;)文件的第六行内容</span><br><span class="line">---</span><br><span class="line">&gt; no six line     &lt;==右边(&gt;)文件第五行内容</span><br></pre></td></tr></table></figure></p><blockquote><p> 很聪明吧！用<code>diff</code>把我们刚刚的处理给比对完毕了！<br><br> <code>diff</code>也可以比较整个目录下的区别<br><br> <code>diff</code>还可以比较不同目录下的相同文件名的内容</p></blockquote><ul><li><b style="color: red">cmp</b></li></ul><p>相对于<code>diff</code>的广泛用途,<code>cmp</code>似乎就用的没有这么多了~<code>cmp</code>主要也是在比对两个文件,他<br>主要利用“字节”单位去比对, 因此,当然也可以比对<code>binary file</code>啰~(还是要再提醒喔,<code>diff</code>主要是以“行”为单位比对,<code>cmp</code>则是以“字节”为单位去比对,这并不相同!)<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp [-l] file1 file2</span><br><span class="line"><span class="meta"># paras:</span></span><br><span class="line">    -l :将所有的不同点的字节处都列出来。因为 cmp 默认仅会输出第一个发现的不同点。</span><br><span class="line"><span class="meta"># examples:</span></span><br><span class="line">    cmp pd pd.<span class="keyword">new</span> </span><br><span class="line">    <span class="meta"># output</span></span><br><span class="line">    pd pd.<span class="keyword">new</span> differ: <span class="keyword">byte</span> <span class="number">120</span>, <span class="built_in">line</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></p><ul><li><b style="color: red">patch</b></li></ul><p>patch 这个指令与 diff 可是有密不可分的关系啊!我们前面提到,diff 可以用来分辨两个版本<br>之间的差异, 举例来说,刚刚我们所创建的<code>pd</code>及<code>pd.new</code>之间就是两个不同版本的文件。那么,如果要“升级”呢?就是“将旧的文件升级成为新的文件”时,应该要怎么做呢?其实也不难啦!就是“先比较先旧版本的差异,并将差异档制作成为补丁文件,再由补丁文件更新旧文件”即可。举例来说,我们可以这样做测试:</p><p><b style="color: red">范例一：</b>以<code>pd</code>与<code>pd.new</code>制作补丁文件<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">diff -Naur pd pd.new  &gt; pd.patch</span><br><span class="line">cat pd.patch</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">--- pd  <span class="number">2018</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">03</span><span class="symbol">:</span><span class="number">58.165695684</span> +080<span class="number">0</span>  &lt;== 新旧文件的信息</span><br><span class="line">+++ pd.new  <span class="number">2018</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span>08<span class="symbol">:</span><span class="number">07</span>.<span class="number">710232163</span> +080<span class="number">0</span></span><br><span class="line">@@ -<span class="number">1</span>,<span class="number">9</span> +<span class="number">1</span>,<span class="number">8</span> @@           &lt;== 新旧文件要修改数据的界定范围，旧文件<span class="number">1</span>-<span class="number">9</span>行，新文件<span class="number">1</span>-<span class="number">8</span>行</span><br><span class="line"> <span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line"> <span class="symbol">daemon:</span><span class="symbol">x:</span><span class="number">1</span><span class="symbol">:</span><span class="number">1</span><span class="symbol">:daemon</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line"> <span class="symbol">bin:</span><span class="symbol">x:</span><span class="number">2</span><span class="symbol">:</span><span class="number">2</span><span class="symbol">:bin</span><span class="symbol">:/bin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">-<span class="symbol">sys:</span><span class="symbol">x:</span><span class="number">3</span><span class="symbol">:</span><span class="number">3</span><span class="symbol">:sys</span><span class="symbol">:/dev</span><span class="symbol">:/usr/sbin/nologin</span>   &lt;== 左侧文件被删除</span><br><span class="line"> <span class="symbol">sync:</span><span class="symbol">x:</span><span class="number">4</span><span class="symbol">:</span><span class="number">65534</span><span class="symbol">:sync</span><span class="symbol">:/bin</span><span class="symbol">:/bin/sync</span>     &lt;== 左侧文件被删除</span><br><span class="line">-<span class="symbol">games:</span><span class="symbol">x:</span><span class="number">5</span><span class="symbol">:</span><span class="number">60</span><span class="symbol">:games</span><span class="symbol">:/usr/games</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">+no six line                            &lt;== 右侧新文件加入</span><br><span class="line"> <span class="symbol">man:</span><span class="symbol">x:</span><span class="number">6</span><span class="symbol">:</span><span class="number">12</span><span class="symbol">:man</span><span class="symbol">:/var/cache/man</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line"> <span class="symbol">lp:</span><span class="symbol">x:</span><span class="number">7</span><span class="symbol">:</span><span class="number">7</span><span class="symbol">:lp</span><span class="symbol">:/var/spool/lpd</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line"> <span class="symbol">mail:</span><span class="symbol">x:</span><span class="number">8</span><span class="symbol">:</span><span class="number">8</span><span class="symbol">:mail</span><span class="symbol">:/var/mail</span><span class="symbol">:/usr/sbin/nologin</span></span><br></pre></td></tr></table></figure></p><p>一般来说,使用<code>diff</code>制作出来的比较文件通常使用扩展名为<code>.patch</code>啰。至于内容就如同上面介绍的样子。基本上就是以行为单位,看看哪边有一样与不一样的,找到一样的地方,然后将不一样的地方取代掉! 以上面表格为例,新文件看到-会删除,看到+会加入!好了,那么如何将<strong>旧的文件更新成为新的内容</strong>呢? 就是将<code>pd</code>改成与<code>pd.new</code>相同!可以这样做:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">patch</span> -pN &lt; <span class="keyword">patch</span>_file &lt;==更新</span><br><span class="line"><span class="keyword">patch</span> -R -pN &lt; <span class="keyword">patch</span>_file &lt;==还原</span><br><span class="line"><span class="comment"># paras:</span></span><br><span class="line">-p :后面可以接“取消几层目录”的意思。</span><br><span class="line">-R :代表还原,将新的文件还原成原来旧的版本。</span><br></pre></td></tr></table></figure></p><p><b style="color: red">范例二：</b>将刚才制作出来的<code>patch file</code>用来更新旧版数据<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">patch -p<span class="number">0</span> &lt; pd.patch</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">patching file pd</span><br><span class="line"></span><br><span class="line">heany<span class="variable">@heany</span><span class="symbol">:~/Desktop/shell-learning</span><span class="variable">$ </span>ll pd*</span><br><span class="line">-rw-r--r-- <span class="number">1</span> heany heany <span class="number">2253</span> <span class="number">4</span>月  <span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">43</span> pd</span><br><span class="line">-rw-r--r-- <span class="number">1</span> heany heany <span class="number">2253</span> <span class="number">4</span>月  <span class="number">11</span> <span class="number">13</span><span class="symbol">:</span>08 pd.new</span><br><span class="line"></span><br><span class="line"><span class="comment">## 两个文件大小一模一样</span></span><br></pre></td></tr></table></figure></p><p><b style="color: red">范例三：</b>将刚才制作出来的<code>patch file</code>恢复旧文件的内容<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">patch -R -p<span class="number">0</span> &lt; pd.patch</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">patching file pd</span><br><span class="line"></span><br><span class="line">heany<span class="variable">@heany</span><span class="symbol">:~/Desktop/shell-learning</span><span class="variable">$ </span>ll pd*</span><br><span class="line">-rw-r--r-- <span class="number">1</span> heany heany <span class="number">2326</span> <span class="number">4</span>月  <span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">47</span> pd</span><br><span class="line">-rw-r--r-- <span class="number">1</span> heany heany <span class="number">2253</span> <span class="number">4</span>月  <span class="number">11</span> <span class="number">13</span><span class="symbol">:</span>08 pd.new</span><br><span class="line"></span><br><span class="line"><span class="comment">## 文件恢复成旧的版本了</span></span><br></pre></td></tr></table></figure></p><blockquote><p> 为什么这里会使用<code>-p0</code>呢?因为我们在比对新旧版的数据时是在同一个目录下,因此不需要减去目录啦!如果是使用整体目录比对(diff旧目录 新目录)时, 就得要依据创建<code>patch</code>文件件所在目录来进行目录的删减啰!</p></blockquote><h4 id="3-4-4、-文件打印准备：pr"><a href="#3-4-4、-文件打印准备：pr" class="headerlink" title="3.4.4、 文件打印准备：pr"></a>3.4.4、 文件打印准备：<code>pr</code></h4><p>如果你曾经使用过一些图形接口的文书处理软件的话,那么很容易发现,当我们在打印的时<br>候, 可以同时选择与设置每一页打印时的标头吧!也可以设置页码呢!那么,如果我是在<br>Linux 下面打印纯文本文件呢 可不可以具有标题啊?可不可以加入页码啊?呵呵!当然可以<br>啊!使用 pr 就能够达到这个功能了。不过, pr 的参数实在太多了,说不完,一般来<br>说,仅使用最简单的方式来处理就行。举例来说,如果想要打印<code>pd</code>呢?<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">heany<span class="variable">@heany</span><span class="symbol">:~/Desktop/shell-learning</span><span class="variable">$ </span>pr pd</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">47</span>                        pd                        Page <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line"><span class="symbol">daemon:</span><span class="symbol">x:</span><span class="number">1</span><span class="symbol">:</span><span class="number">1</span><span class="symbol">:daemon</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line"><span class="symbol">bin:</span><span class="symbol">x:</span><span class="number">2</span><span class="symbol">:</span><span class="number">2</span><span class="symbol">:bin</span><span class="symbol">:/bin</span><span class="symbol">:/usr/sbin/nologin</span></span><br><span class="line">....................下面省略..........</span><br></pre></td></tr></table></figure></p><h2 id="四、-学习Shell-Scripts"><a href="#四、-学习Shell-Scripts" class="headerlink" title="四、 学习Shell Scripts"></a>四、 学习<b style="color: red">Shell Scripts</b></h2><h3 id="4-1、什么是shell-script"><a href="#4-1、什么是shell-script" class="headerlink" title="4.1、什么是shell script"></a>4.1、什么是shell script</h3><p><code>shell script</code>可以简单的被看成是批处理文件,也可以被说成是一个程序语言,且这个程序语言由于都是利用<code>shell</code>与相关工具指令, 所以不需要编译即可执行,且拥有不错的除错(debug)工具,所以,他可以帮助系统管理员快速的管理好主机。</p><p><code>shell script</code>其实就是纯文本文件,我们可以编辑这个文件,然后让这个文件来帮我们一次执行多个指令,或者是利用一些运算与逻辑判断来帮我们达成某些功能。所以啦,要编辑这个文件的内容时,当然就需要具备有 bash 指令下达的相关认识。下达指令需要注意的事项在第四章的开始下达指令小节内已经提过,有疑问请自行回去翻阅。 在<code>shell script</code>的撰写中还需要用到下面的注意事项:</p><pre><code>1. 指令的执行是从上而下、从左到右的分析与执行;2. 指令的下达：指令、选项与参数间的多个空白都会被忽略掉;3. 空白行也将被忽略掉,并且 [tab] 按键所得的空白同样视为空格键;4. 如果读取到一个Enter符号（CR），就尝试开始执行该行（该串）命令;5. 至于如果一行的内容太多，则可以使用&quot;[Enter]&quot;来延伸至下一行;6. “ # ”可做为注解!任何加在 # 后面的数据将全部被视为注解文字而被忽略!</code></pre><p>如此一来,我们在<code>script</code>内所撰写的程序,就会被一行一行的执行。现在我们假设你写的这个程序文件名是<code>/home/heany/Desktop/shell-learning/shell.sh</code>好了,那如何执行这个文件?很简单,可以有下面几个方法:</p><ul><li><p>直接下达指令：<code>shell.sh</code>文件必须要具备可读与可执行（rx）的权限，然后：</p><p>  绝对路径：使用<code>/home/heany/Desktop/shell-learning/shell.sh</code>来下达指令;<br><br>  相对路径：假设工作目录在<code>/home/heany/Desktop/shell-learning</code>，则使用<code>./shell.sh</code>来执行;<br><br>  变量<code>PATH</code>功能：将<code>shell.sh</code>放在PATH指定的目录内，例如：<code>~/bin/</code></p></li><li><p>以<code>bash</code>程序来执行：通过”bash shell.sh”或<code>sh shell.sh</code>来执行。</p></li><li>编写第一个<code>script</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Program:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    This program shows <span class="string">"Hello World!"</span> <span class="keyword">in</span> your screen.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> History:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2018/04/11  VBird   First release</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line">echo -e "Hello World! \a \n"</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li></ul><p>程序说明如下：</p><ul><li><strong>第一行<code>#!/bin/bash</code>在宣告这个script使用的shell名称</strong>: 因为我们使用的是bash ,所以,必须要以<code>#!/bin/bash</code>来宣告这个文件内的语法使用bash语法!那么当这个程序被执行时,他就能够载入<code>bash</code>的相关环境配置文件 (一般来说就是<code>non-login shell</code>的 ~/.bashrc), 并且执行<code>bash</code>来使我们下面的指令能够执行!这很重要的!(在很多状况中,如果没有设置好这一行,那么该程序很可能会无法执行,因为系统可能无法判断该程序需要使用什么 shell 来执行啊!)</li><li><strong>程序内容的说明</strong>: 整个 script 当中,除了第一行的<code>#!</code>是用来宣告shell的之外,其他的<code>#</code>都是“注解”用途! 所以上面的程序当中,第二行以下就是用来说明整个程序的基本数据。一般来说, 建议你一定要养成说明该 script 的:1. 内容与功能; 2. 版本信息; 3.作者与联络方式; 4. 创建日期;5. 历史纪录 等等。这将有助于未来程序的改写与 debug呢!</li><li><strong>主要环境变量的声明</strong>: 建议务必要将一些重要的环境变量设置好,个人认为,<code>PATH</code>与<code>LANG</code> (如果有使用到输出相关的信息时) 是当中最重要的! 如此一来,则可让我们这支程序在进行时,可以直接下达一些外部指令,而不必写绝对路径呢!比较方便啦！</li><li><strong>主要程序部分</strong>就将主要的程序写好即可！在这个例子当中，就是echo那一行。</li><li><p><strong>告知执行结果</strong>：一个命令的执行成功与否，可以使用<code>$?</code>这个变量来观察～那么我们也可以利用<code>exit</code>这个指令来让程序中断，并且回传一个数值给系统。在我们这个例子当中,我使用<code>exit 0</code>,这代表离开<code>script</code>并且回传一个<code>0</code>给系统, 所以我执行完这个<code>script</code>后,若接着下达<code>echo $?</code> 则可得到<code>0</code>的值喔! 更聪明的读者应该也知道了!利用这个<code>exit n</code>(n 是数字) 的功能,我<br>们还可以自订错误讯息, 让这支程序变得更加的<code>smart</code>呢!</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x hello.sh</span><br><span class="line"><span class="string">./hello.sh</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure></li><li><p><b style="color: red;font-size: 24px">编写<code>shell script</code>的良好习惯</b></p></li></ul><p>一个良好习惯的养成是很重要的~大家在刚开始撰写程序的时候,最容易忽略这部分, 认为<br>程序写出来就好了,其他的不重要。其实,如果程序的说明能够更清楚,那么对你自己是有<br>很大的帮助的。<b style="color: red">要学会比较仔细的将程序的设计过程给它记录下来，而且记录一些历史记录</b>。在每个<code>script</code>的文件开始处记录好：</p><pre><code>1. `script`的功能2. `script`的版本信息3. `script`的作者与联系方式4. `script`的版权声明方式5. `script`的`History`（历史记录）6. `script`内比较特殊的指令，使用“绝对路径”的方式下达7. `script`运行时需要的环境变量预先宣告与设置8. 在较为特殊程序代码部分，加上适当的注释说明</code></pre><blockquote><p> 程序代码的编写最好使用嵌套方式，<strong>最好能以<code>[tab]</code>按键的空格缩排</strong>这样代码看起来非常漂亮与有条理。</p></blockquote><h3 id="4-2、-简单的shell练习"><a href="#4-2、-简单的shell练习" class="headerlink" title="4.2、 简单的shell练习"></a>4.2、 简单的<code>shell</code>练习</h3><h4 id="4-2-1、-简单范例"><a href="#4-2-1、-简单范例" class="headerlink" title="4.2.1、 简单范例"></a>4.2.1、 简单范例</h4><ul><li>交互式脚本：变量内容由用户决定</li></ul><p>请你以<code>read</code>命令的用途,编写一个<code>script</code>,他可以让使用者输入first name与last name,最后并且在屏幕上显示:“Your full name is: ”的内容:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># showname.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># paragram:</span></span><br><span class="line"><span class="comment">#       User inputs his first name and last name. Program shows his full name.</span></span><br><span class="line"><span class="comment"># History</span></span><br><span class="line"><span class="comment"># 2018/04/11   heany  First release</span></span><br><span class="line">PATH=<span class="regexp">/bin:/sbin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/local/bin</span><span class="symbol">:/usr/local/sbin</span><span class="symbol">:~/bin</span></span><br><span class="line">export PATH</span><br><span class="line"><span class="comment"># 提示使用者输入</span></span><br><span class="line">read -p <span class="string">"Please input your first name: "</span> firstname</span><br><span class="line"><span class="comment"># 提示使用者输入</span></span><br><span class="line">read -p <span class="string">"Please input your last name: "</span> lastname</span><br><span class="line"><span class="comment"># 结果由屏幕输出</span></span><br><span class="line">echo -e <span class="string">"\nYour full name is: $&#123;firstname&#125; $&#123;lastname&#125;"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行脚本</span></span><br><span class="line"> .  showname.sh</span><br><span class="line">Please input your first <span class="symbol">name:</span> heany</span><br><span class="line">Please input your last <span class="symbol">name:</span> boy</span><br><span class="line"></span><br><span class="line">Your full name <span class="symbol">is:</span> heany boy</span><br></pre></td></tr></table></figure></p><ul><li>随日期变化：利用<code>data</code>进行文件的创建</li></ul><p>想像一个状况,假设我的服务器内有数据库,数据库每天的数据都不太一样,因此当我备份时,希望将每天的数据都备份成不同的文件名,这样才能够让旧的数据也能够保存下来不被覆盖。哇!不同文件名呢!这真困扰啊?难道要我每天去修改<code>script</code>?</p><p>不需要啊!考虑每天的“日期”并不相同,所以我可以将文件名取成类似:<code>backup.2015-07-16.data</code>, 不就可以每天一个不同文件名了吗?呵呵!确实如此。那个<code>2015-07-16</code>怎么来的?那就是重点啦!接下来出个相关的例子: 假设我想要创建三个空的文件 (通过 touch)文件名最开头由使用者输入决定,假设使用者输入<code>filename</code>好了,那今天的日期是<code>2015/07/16</code>, 我想要以前天、昨天、今天的日期来创建这些文件,亦即filename_20150714,filename_20150715, filename_20150716 ,该如何是好?<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># program:</span></span><br><span class="line"><span class="comment">#       Program creates three files, which named by user's input and date command.</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2018/04/11    heany   First release</span></span><br><span class="line">PATH=<span class="regexp">/bin:/sbin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/local/bin</span><span class="symbol">:/usr/local/sbin</span><span class="symbol">:~/bin</span></span><br><span class="line">export PATH</span><br><span class="line"><span class="comment"># 1. 让使用者输入文件名称,并取得 fileuser 这个变量;</span></span><br><span class="line">echo -e <span class="string">"I will use 'touch' command to create 3 files."</span> <span class="comment"># 纯粹显示信息</span></span><br><span class="line">read -p <span class="string">"Please input your filename: "</span> fileuser         <span class="comment"># 提示使用者输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 为了避免使用者随意按Enter,利用变量功能分析文件名是否有设置</span></span><br><span class="line">filename=<span class="variable">$&#123;</span><span class="symbol">fileuser:</span>-<span class="string">"filename"</span>&#125;                <span class="comment"># 开始判断有否配置文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 开始利用 date 指令来取得所需要的文件名了;</span></span><br><span class="line">date1=<span class="variable">$(</span>date --date=<span class="string">'2 days ago'</span> +%Y%m%d)       <span class="comment"># 前两天的日期</span></span><br><span class="line">date2=<span class="variable">$(</span>date --date=<span class="string">'1 days ago'</span> +%Y%m%d)       <span class="comment"># 前一天的日期</span></span><br><span class="line">date3=<span class="variable">$(</span>date +%Y%m%d)                           <span class="comment"># 今天的日期</span></span><br><span class="line">file1=<span class="variable">$&#123;</span>filename&#125;<span class="variable">$&#123;</span>date1&#125;                       <span class="comment"># 下面三行在配置文件名</span></span><br><span class="line">file2=<span class="variable">$&#123;</span>filename&#125;<span class="variable">$&#123;</span>date2&#125;</span><br><span class="line">file3=<span class="variable">$&#123;</span>filename&#125;<span class="variable">$&#123;</span>date3&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p> 在一串命令中如果还需要通过其他的命令提供的信息，可以使用反单引号`命令`或<code>$</code>(命令)。<code>filename=${fileuser:-&quot;filename&quot;}</code>，这条命令用来判断<code>fileuser</code>是否已经赋值，<code>:-</code>是一起的，<code>fileuser</code>如果有值的话，就用所拥有的值赋给<code>filename</code>变量，如果没有值的话，就把”filename”赋给<code>fileuser</code>，再赋给<code>filename</code>变量。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">v</span>=$(uname -r)</span><br><span class="line">echo <span class="variable">$v</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">4.13.0-38-generic</span><br><span class="line"></span><br><span class="line"><span class="attribute">vv</span>=`uname -r`</span><br><span class="line">echo <span class="variable">$vv</span></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">4.13.0-38-generic</span><br></pre></td></tr></table></figure><ul><li>数值运算：简单的加减乘除</li></ul><p>我们可以使用<code>declare</code>来定义变量的类型吧? 当变量定义成为整数后才能够进行加减运算啊!此外,我们也可以利用<strong><code>$((计算式))</code></strong>来进行数值运算的。可惜的是,<code>bash shell</code>里头默认仅支持到整数的数据而已。OK!那我们来玩玩看,如果我们要使用者输入两个变量, 然后将两个变量的内容相乘,最后输出相乘的结果,那可以怎么做?<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Program:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       User inputs 2 <span class="built_in">integer</span> numbers; program will cross thest two numbers.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> History:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2018/04/11    heany   First release</span></span><br><span class="line"></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">echo -e "You SHOULD input 2 numbers, I will multiplying them! \n"</span><br><span class="line">read -p "first number: " firstnu</span><br><span class="line">read -p "second number: " secnu</span><br><span class="line">total=$(($&#123;firstnu&#125;*$&#123;secnu&#125;))</span><br><span class="line">echo -e "\nThe result of $firstnu x $secnu is ==&gt; $total"</span><br></pre></td></tr></table></figure></p><blockquote><p> 在数值计算上，我们还可以使用<strong><code>declare -i total=$fistnu*$secnu</code></strong>,不推荐使用这种方式，因为比较繁琐，不容易记。使用上面程序中的那种方式来计算数值。</p></blockquote><p>如果想要计算含有小数点的数据时，其实可以通过<code>bc</code>这个指令的协助，例如：</p><pre><code>echo &quot;123.123*55.9&quot; | bc# output6882.575</code></pre><h3 id="4-3、-善用判断式"><a href="#4-3、-善用判断式" class="headerlink" title="4.3、 善用判断式"></a>4.3、 善用判断式</h3><p><code>$?</code>这个变量代表的是上一条命令执行的情况，若没问题则回传码为<code>0</code>,若存在问题，回传错误代码(非0), 此外,也通过<code>&amp;&amp;</code>及<code>||</code>来作为前一个指令执行回传值对于后一个指令是否要进行的依据。我们知道想要判断一个目录是否存在, 之前我们使用的是ls这个指令搭配数据流重导向,最后配合<code>$?</code>来决定后续的指令进行与否。但是否有更简单的方式可以来进行“条件判断”呢?有的~那就是<code>test</code>这个指令。</p><h4 id="4-3-1、-利用test指令的测试功能"><a href="#4-3-1、-利用test指令的测试功能" class="headerlink" title="4.3.1、 利用test指令的测试功能"></a>4.3.1、 利用<code>test</code>指令的测试功能</h4><p>当我们要检测系统上面某些文件或者是相关的属性时，利用<code>test</code>这个指令来工作真是好用得炸了，举例来说，我要检查<code>/heany</code>是否存在时，使用：</p><pre><code>test -e /heany</code></pre><p>执行结果不会显示任何信息，但最后我们可以通过<code>$?</code>或<code>&amp;&amp;及||</code>来展现整个结果！例如我们在将上面的例子改写成这样：</p><pre><code>test -e /heany &amp;&amp; echo &quot;exist&quot; || echo &quot;No exist&quot;# outputNo exist  ==&gt; 结果显示不存在</code></pre><p>最终的结果可以告知我们是<code>exist</code>还是<code>Not exist</code>呢!那我知道<code>-e</code>是测试一个“东西”在不在,<br>如果还想要测试一下该文件名是啥玩意儿时,还有哪些标志可以来判断的呢?呵呵!有下面这些东西喔!</p><ol><li>关于某个文件名的”文件类型”判断，如<code>test -e filename</code>表示存在与否</li></ol><table><thead><tr><th style="text-align:center">测试的标志</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:center">-e</td><td style="text-align:center">该文件名是否存在</td></tr><tr><td style="text-align:center">-f</td><td style="text-align:center">该文件名是否存在且问文件</td></tr><tr><td style="text-align:center">-d</td><td style="text-align:center">该文件名是否存在且为目录</td></tr><tr><td style="text-align:center">-b</td><td style="text-align:center">该文件名是否存在且为一个<code>block device</code>设备</td></tr><tr><td style="text-align:center">-c</td><td style="text-align:center">该文件名是否存在且为一个<code>character device</code>设备</td></tr><tr><td style="text-align:center">-S</td><td style="text-align:center">该文件名是否存在且为一个Socket文件</td></tr><tr><td style="text-align:center">-p</td><td style="text-align:center">该文件名是否存在且为一个FIFO（pipe）文件</td></tr><tr><td style="text-align:center">-L</td><td style="text-align:center">该文件名是否存在且为一个链接文件</td></tr></tbody></table><ol start="2"><li>关于文件的权限侦测，如<code>test -r filename</code>表示可读否（但root权限常有例外）</li></ol><p><img src="https://wx4.sinaimg.cn/mw1024/e0db46edgy1fq90rrorbrj20m607p0u0.jpg" align="center"></p><ol start="3"><li>两个文件之间的比较，如：<code>test file1 -nt file2</code></li></ol><table><thead><tr><th style="text-align:center">测试的标志</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:center">-nt</td><td style="text-align:center">(newer than)判断<code>file1</code>是否比<code>file2</code>新</td></tr><tr><td style="text-align:center">-ot</td><td style="text-align:center">(older than)判断<code>file1</code>是否比<code>file2</code>旧</td></tr><tr><td style="text-align:center">-ef</td><td style="text-align:center">判断 file1 与 file2 是否为同一文件,<br>可用在判断<code>hard link</code>的判定上。<br>主要意义在判定,两个文件是否均指向同一个<code>inode</code></td></tr></tbody></table><ol start="4"><li>关于两个整数之间的判定，例如：<code>test n1 -eq n2</code></li></ol><p><img src="https://wx4.sinaimg.cn/mw1024/e0db46edgy1fq90rrpaszj20mf06n74s.jpg" align="center"></p><ol start="5"><li>判定字串的数据</li></ol><p><img src="https://wx3.sinaimg.cn/mw1024/e0db46edgy1fq90rrp8zij20mc050mxw.jpg" align="center"></p><ol start="6"><li>多重条件判定，例如：<code>test -r filename -a -x filename</code></li></ol><table><thead><tr><th style="text-align:center">测试的标志</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:center">两个条件同时成立！<br>例如 <code>test -r file -a -x file</code>,则file同时具有r与x权限时。才回传true</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:center">(or)两状况任何一个成立!例如 test -r file -o -x file,则 file 具有 r 或 x 权限时,就可回传 true。</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">反相状态,如<code>test ! -x file</code>,当file不具有x时,回传<code>true</code></td></tr></tbody></table><p>现在我们利用<code>test</code>来帮我们写几个简单的例子。首先，判断一下，让使用者输入一个文件名，我们判断：</p><ol><li>这个文件是否存在，若不存在则给予一个”Filename does not exist”的信息，并中断程序; </li><li>若这个文件存在，则判断他是个文件或目录，结果输出“Filename is regular file”或”Filename is directory”</li><li>判断一下，执行者的身份对这个文件或目录所拥有的权限，并输出权限数据！</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Program:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       User input a filename, program will check flowing:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       1. exist?  2. file/directory?  3. file permisions</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> History:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2018/04/11    heany   First release</span></span><br><span class="line"></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1. 让使用者输入文件名,并且判断使用者是否真的有输入字串?</span></span><br><span class="line">echo -e "Please input a filename, I will check the filename's type and permission. \n\n"</span><br><span class="line">read -p "Input a filename : " filename</span><br><span class="line">test -z $&#123;filename&#125; &amp;&amp; echo "You MUST input a filename." &amp;&amp; exit 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 判断文件是否存在?若不存在则显示信息并结束脚本</span></span><br><span class="line">test ! -e $&#123;filename&#125; &amp;&amp; echo "The filename '$&#123;filename&#125;' DO NOT exist" &amp;&amp; exit 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 开始判断文件类型与属性</span></span><br><span class="line">test -f $&#123;filename&#125; &amp;&amp; filetype="regulare file"</span><br><span class="line">test -d $&#123;filename&#125; &amp;&amp; filetype="directory"</span><br><span class="line">test -r $&#123;filename&#125; &amp;&amp; perm="readable"</span><br><span class="line">test -w $&#123;filename&#125; &amp;&amp; perm="$&#123;perm&#125; writable"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 开始输出信息!</span></span><br><span class="line">echo "The filename: $&#123;filename&#125; is a $&#123;filetype&#125;"</span><br><span class="line">echo "And the permissions for you are : $&#123;perm&#125;"</span><br></pre></td></tr></table></figure><h4 id="4-3-2、-利用判断符号"><a href="#4-3-2、-利用判断符号" class="headerlink" title="4.3.2、 利用判断符号[]"></a>4.3.2、 利用判断符号<code>[]</code></h4><p>除了我们很喜欢使用的<code>test</code>之外,其实,我们还可以利用判断符号<code>[ ]</code>(就是中括号啦)来进行数据的判断呢! 举例来说,如果我想要知道<code>${HOME}</code>这个变量是否为空的,可以这样做:</p><pre><code>[ -z &quot;$HOME&quot;] ; echo $?</code></pre><blockquote><p> 使用中括号必须要特别注意,因为中括号用在很多地方,包括万用字符与正则表达式等等,所以如果要在 bash 的语法当中使用中括号作为<code>shell</code>的判断式时,必须要注意<b style="color: red">中括号的两端需要有空白字符来分隔!</b> 假设我空白键使用“□”符号来表示,那么,在这些地方你都需要有空白键:</p></blockquote><pre><code>[ &quot;$HOME&quot; == &quot;$MAIL&quot;][□&quot;$HOME&quot;□==□&quot;$MAIL&quot;□]</code></pre><p>可是差很多的喔!另外,<strong>中括号的使用方法与<code>test</code>几乎一模一样啊~ </strong>只是中括号比较常用在条件判断式<code>if ..... then ..... fi</code>的情况中就是了。好,那我们也使用中括号的判断来做一个小案例好了,案例设置如下:</p><pre><code>1. 当执行一个程序的时候,这个程序会让使用者选择 Y 或 N ,2. 如果使用者输入Y或y时，就显示&quot;OK， continue&quot;3. 如果使用者输入 n 或 N 时,就显示“ Oh, interrupt !”4. 如果不是 Y/y/N/n 之内的其他字符,就显示“ I don&apos;t know what your choice is ”</code></pre><p>利用中括号、&amp;&amp;与||来继续吧！<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Program:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       This program shows the user<span class="string">'s choice.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> History:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2018/04/11    heany   First release</span></span><br><span class="line"></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">read -p "Please input (Y/N): " yn</span><br><span class="line">[ "$&#123;yn&#125;" == "Y" -o "$&#123;yn&#125;" == "y" ] &amp;&amp; echo "OK, continue" &amp;&amp; exit 0</span><br><span class="line">[ "$&#123;yn&#125;" == "N" -o "$&#123;yn&#125;" == "n" ] &amp;&amp; echo "Oh, interrupt!" &amp;&amp; exit 0</span><br><span class="line">echo "I don't know what your choice is" &amp;&amp; exit 0</span><br></pre></td></tr></table></figure></p><blockquote><p> 这里使用<code>-o</code>来链接两个判断</p></blockquote><h4 id="4-3-3、-Shell-Script的默认变量（-0-1…）"><a href="#4-3-3、-Shell-Script的默认变量（-0-1…）" class="headerlink" title="4.3.3、 Shell Script的默认变量（$0,$1…）"></a>4.3.3、 <strong><code>Shell Script</code></strong>的默认变量（$0,$1…）</h4><p>我们知道指令可以带有选项与参数,例如<code>ls -la</code>可以察看包含隐藏文件的所有属性与权限。那么<code>shell script</code>能不能在脚本文件名后面带有参数呢?很有趣喔!举例来说,如果你想要重新启动系统的网络,可以这样做:</p><pre><code>file /etc/init.d/network/etc/init.d/network restart   # 重启</code></pre><p>restart 是重新启动的意思,上面的指令可以“重新启动 /etc/init.d/network 这支程序”的意思!唔!那么如果你在 /etc/init.d/network 后面加上 stop 呢?没错!就可以直接关闭该服务了!这么神奇啊? 错啊!如果你要依据程序的执行给予一些变量去进行不同的任务时,本章一开始是使用 read 的功能!但 read 功能的问题是你得要手动由键盘输入一些判断式。如果通过指令后面接参数, 那么一个指令就能够处理完毕而不需要手动再次输入一些变量行为!这样下达指令会比较简单方便啦!</p><p>script 是怎么达成这个功能的呢?其实 script 针对参数已经有设置好一些变量名称了!对应如下:<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/path/<span class="keyword">to</span>/scriptname     opt1    opt2    opt3    opt4</span><br><span class="line">        $0               $1      $2      $3      $4</span><br></pre></td></tr></table></figure></p><p>这样够清楚了吧?执行的脚本文件名为<code>$0</code>这个变量,第一个接的参数就是<code>$1</code>啊~ 所以,只要我们在 script 里面善用<code>$1</code>的话,就可以很简单的立即下达某些指令功能了!除了这些数字的变量之外, 我们还有一些较为特殊的变量可以在<code>script</code>内使用来调用这些参数喔!</p><pre><code>$# :代表后接的参数“个数”,以上表为例这里显示为“ 4 ”;$@ :代表“ &quot;$1&quot; &quot;$2&quot; &quot;$3&quot; &quot;$4&quot; ”之意,每个变量是独立的(用双引号括起来);$* :代表“ &quot;$1&lt;u&gt;c&lt;/u&gt;$2&lt;u&gt;c&lt;/u&gt;$3&lt;u&gt;c&lt;/u&gt;$4&quot; ”,&lt;br&gt;    其中 &lt;u&gt;c&lt;/u&gt; 为分隔字符,默认为空白键, 所以本例中代表“ &quot;$1 $2 $3 $4&quot; ”之意。</code></pre><p>来练习：假设我们要执行一个可以携带参数的<code>script</code>，执行该脚本后屏幕会显示如下数据：</p><pre><code>程序的文件名为何？共有几个参数？若参数的个数小于2则告知使用者参数数量太少全部的参数内容为何？第一个参数为何？第二个参数为何？</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Program:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       Program shows the script name, parameters and so on....</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> History:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2018/04/12    heany   First release</span></span><br><span class="line"></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">echo "The script name is ===&gt;  $0"</span><br><span class="line">echo "Total parameter number is ===&gt; $#"</span><br><span class="line">[ "$#" -lt 2 ] &amp;&amp; echo "The number of parameter is less than 2.  Stop here."\</span><br><span class="line">        &amp;&amp; exit 0</span><br><span class="line">echo "Your whole parameter is ==&gt; '$@'"</span><br><span class="line">echo "The 1st parameter   ===&gt; $1"</span><br><span class="line">echo "The 2nd parameter   ===&gt; $2"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 脚本执行</span></span><br><span class="line">sh how_paras.sh I am a boy</span><br><span class="line"><span class="meta">#</span><span class="bash"> output</span></span><br><span class="line">The script name is ===&gt;  how_paras.sh</span><br><span class="line">Total parameter number is ===&gt; 4</span><br><span class="line">Your whole parameter is ==&gt; 'I am a boy'</span><br><span class="line">The 1st parameter   ===&gt; I</span><br><span class="line">The 2nd parameter   ===&gt; am</span><br></pre></td></tr></table></figure><ul><li><code>shift</code>：造成参数变量号码偏移</li></ul><p>什么是偏移（shift）呢？我们用下面的范例来说明下，我们将<code>how_paras.sh</code>的内容稍作变化，用来显示每次偏移后参数的变化情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Program:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       Program shows the effect of <span class="built_in">shift</span> <span class="keyword">function</span>....</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> History:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2018/04/12    heany   First release</span></span><br><span class="line"></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">echo "Total parameter number is ===&gt;  $#"</span><br><span class="line">echo "Your whole parameter is   ===&gt; '$@'"</span><br><span class="line"></span><br><span class="line">shift   # 进行第一次"一个变量的 shift"</span><br><span class="line">echo "Total parameter number is ===&gt;  $#"</span><br><span class="line">echo "Your whole parameter is   ===&gt; '$@'"</span><br><span class="line"></span><br><span class="line">shift 3 #进行第二次"三个变量的 shift"</span><br><span class="line">echo "Total parameter number is ===&gt;  $#"</span><br><span class="line">echo "Your whole parameter is   ===&gt; '$@'"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> execute script</span></span><br><span class="line">sh paras_shift.sh one two three four five six </span><br><span class="line"><span class="meta">#</span><span class="bash"> output</span></span><br><span class="line">Total parameter number is ===&gt;  6</span><br><span class="line">Your whole parameter is   ===&gt; 'one two three four five six'</span><br><span class="line">Total parameter number is ===&gt;  5</span><br><span class="line">Your whole parameter is   ===&gt; 'two three four five six'</span><br><span class="line">Total parameter number is ===&gt;  2</span><br><span class="line">Your whole parameter is   ===&gt; 'five six'</span><br></pre></td></tr></table></figure></p><p>光看结果你就可以知道啦,那个<code>shift</code>会移动变量,而且<code>shift</code>后面可以接数字,代表拿掉最前面的几个参数的意思。 上面的执行结果中,第一次进行<code>shift</code> 后他的显示情况是<code>one two three four five six</code>,所以就剩下五个啦!第二次直接拿掉三个,就变成<code>two three four five six</code>啦!这样这个案例可以了解了吗?理解了<code>shift</code>的功能了吗?</p><h3 id="4-4、-条件判断式"><a href="#4-4、-条件判断式" class="headerlink" title="4.4、 条件判断式"></a>4.4、 条件判断式</h3><h4 id="4-4-1、-利用if-then"><a href="#4-4-1、-利用if-then" class="headerlink" title="4.4.1、 利用if .... then"></a>4.4.1、 利用<code>if .... then</code></h4><ul><li>单层、简单条件判断</li></ul><p>如果你只有一个判断式要进行，那么我们可以简单的这样看：</p><pre><code>if [ 条件判断式 ]; then    当条件判断式成立时，可以进行命令工作内容fi &lt;=== 将`if`反过来写，就成为`fi`，结束`if`的意思。</code></pre><p>条件判断式有多个条件时，可以将多个条件写入一个中括号里面，也可以有多个中括号来隔开。括号之间，则用<code>&amp;&amp;与||</code>来隔开。举上面的<code>ans_yn.sh</code>例子来说明，修改里面的判断式：</p><pre><code>[ &quot;$yn&quot; == &quot;Y&quot; -o &quot;$yn&quot; == &quot;y&quot; ] 上式可替换为 [ &quot;$yn&quot; == &quot;Y&quot; ] || [ &quot;$yn&quot; == &quot;y&quot; ]</code></pre><blockquote><p> 这样符合人们的习惯问题，我们都喜欢一个中括号仅有一个判别式。接下来，我们将<code>ans_yn.sh</code>这个脚本修改成为<code>if ... then</code>的样式：</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       This program shows the user's choice.</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2018/04/11    heany   First release</span></span><br><span class="line"></span><br><span class="line">PATH=<span class="regexp">/bin:/sbin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/local/bin</span><span class="symbol">:/usr/local/sbin</span><span class="symbol">:~/bin</span></span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">read -p <span class="string">"Please input (Y/N): "</span> yn</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$yn"</span> == <span class="string">"Y"</span> ] <span class="params">||</span> [ <span class="string">"$yn"</span> == <span class="string">"y"</span> ]; <span class="keyword">then</span></span><br><span class="line">        echo <span class="string">"OK, continue."</span></span><br><span class="line">        exit <span class="number">0</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$yn"</span> == <span class="string">"N"</span> ] <span class="params">||</span> [ <span class="string">"$yn"</span> == <span class="string">"n"</span> ]; <span class="keyword">then</span></span><br><span class="line">        echo <span class="string">"Oh, interrupt!"</span></span><br><span class="line">        exit <span class="number">0</span></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo <span class="string">"I don't know what your choice is"</span> &amp;&amp; exit <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>多重、复杂条件判断式</li></ul><p>在同一个数据的判断中,如果该数据需要进行多种不同的判断时,应该怎么作?举例来说,上面的 ans_yn.sh 脚本中,我们只要进行一次 ${yn} 的判断就好 (仅进行一次 if ),不想要作多次 if 的判断。 此时你就得要知道下面的语法了:</p><pre><code># 一个条件判断，分成功进行与失败进行(else)if [ 条件判断式一 ]; then    当条件判断式成立时，可以进行的指令工作内容：elif [ 条件判断式二 ]; then    当条件判断式二成立时，可以进行的指令工作内容else    当条件判断式一和二都不成立时，可以进行的指令工作内容;fi </code></pre><p>一般来说，如果你不希望使用者由键盘输入额外的数据时，可以使用上面提到的参数功能（$1），让使用者在下达命令时就将参数带进去！现在我们想让使用者输入<code>hello</code>这个关键字时，利用参数的方法可以这样依序设计：</p><pre><code>1. 判断`$1`是否为hello，如果是的话，就显示“hello，how are you？”2. 如果没有加任何参数,就提示使用者必须要使用的参数下达法;3. 而如果加入的参数不是 hello ,就提醒使用者仅能使用 hello 为参数。</code></pre><p>之前我们已经学会了<code>grep</code>这个好用的玩意儿，那么多学一个叫做<code>netstat</code>的命令，这个指令可以查询到目前主机有打开的网络服务端口（service ports）,我们可以利用<code>netstat -tuln</code>来取得目前主机有启动的服务，而且取得的信息有点像这样：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">netstat</span> <span class="selector-tag">-tuln</span></span><br><span class="line"><span class="selector-tag">Active</span> <span class="selector-tag">Internet</span> <span class="selector-tag">connections</span> (<span class="selector-tag">only</span> <span class="selector-tag">servers</span>)</span><br><span class="line"><span class="selector-tag">Proto</span> <span class="selector-tag">Recv-Q</span> <span class="selector-tag">Send-Q</span> <span class="selector-tag">Local</span> <span class="selector-tag">Address</span>           <span class="selector-tag">Foreign</span> <span class="selector-tag">Address</span>         <span class="selector-tag">State</span>      </span><br><span class="line"><span class="selector-tag">tcp</span>        0      0 0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-pseudo">:5355</span>            0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span>:*               <span class="selector-tag">LISTEN</span>     </span><br><span class="line"><span class="selector-tag">tcp</span>        0      0 0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-pseudo">:22</span>              0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span>:*               <span class="selector-tag">LISTEN</span>     </span><br><span class="line"><span class="selector-tag">tcp</span>        0      0 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:631</span>           0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span>:*               <span class="selector-tag">LISTEN</span>     </span><br><span class="line"><span class="selector-tag">tcp</span>        0      0 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:1080</span>          0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span>:*               <span class="selector-tag">LISTEN</span>    </span><br><span class="line"><span class="selector-tag">udp</span>        0      0 0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-pseudo">:5353</span>            0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span>:*                          </span><br><span class="line"><span class="selector-tag">udp</span>        0      0 0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-pseudo">:5353</span>            0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span>:*                      </span><br><span class="line">#封包格式           本地<span class="selector-tag">IP</span>：端口              远程<span class="selector-tag">IP</span>：端口              是否监听</span><br></pre></td></tr></table></figure></p><p>上面的重点是“Local Address (本地主机的IP与端口对应)”那个字段,他代表的是本机所启动的网络服务! IP的部分说明的是该服务位于那个接口上,若为 127.0.0.1 则是仅针对本机开放,若是 0.0.0.0 或 ::: 则代表对整个<code>Internet</code>开放。 每个端口 (port) 都有其特定的网络服务,几个常见的 port 与相关网络服务的关系是:</p><pre><code>80：www22:ssh21:ftp25:mail111:RPC(远端程序调用)631:CUPS（打印服务功能）</code></pre><p>假设我的主机有兴趣要侦测的是比较常见的 port 21, 22, 25及 80 时,那我如何通过<code>netstat</code>去侦测我的主机是否有打开这四个主要的网络服务端口呢?由于每个服务的关键字都是接在冒号<code>:</code>后面, 所以可以借由提取类似<code>:80</code>来侦测的!那我就可以简单的这样去写这个程序喔:</p><h4 id="4-4-2、-利用case-esac"><a href="#4-4-2、-利用case-esac" class="headerlink" title="4.4.2、 利用case ... esac"></a>4.4.2、 利用<code>case ... esac</code></h4><p>语法如下：</p><pre><code>case $变量名称 in      &lt;=== 关键字为case。还有变量前有$    &quot;第一个变量内容&quot;)   &lt;=== 每个变量内容建议用双引号括起来，关键字则为小括号）        程序段        ;;            &lt;=== 每个类别结尾i使用两个连续的分号来处理    &quot;第二个变量内容&quot;）        程序段        ;;    *)                &lt;=== 最后一个变量内容都会用*来代表所有其他值        不包括第一个变量内容与第二个变量内容的其他程序执行段        exit 1        ;;esac                  &lt;=== 最终的case结尾，“反过来写”</code></pre><p>这么说或许你的感受性还不高,好,我们直接写个程序来玩玩:让使用者能够输入 one, two,three , 并且将使用者的变量显示到屏幕上,如果不是 one, two, three 时,就告知使用者仅有这三种选择。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#        This script only accepts the flowing parameter: one, two or three.</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2018/04/12    heany   Fist release</span></span><br><span class="line">PATH=<span class="regexp">/bin:/sbin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/local/bin</span><span class="symbol">:/usr/local/sbin</span><span class="symbol">:~/bin</span></span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">echo <span class="string">"This program will print your selection !"</span></span><br><span class="line"><span class="comment"># read -p "Input your choice: " choice          # 暂时取消,可以替换!</span></span><br><span class="line"><span class="comment"># case $&#123;choice&#125; in                     # 暂时取消,可以替换!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;</span><span class="number">1</span>&#125; <span class="keyword">in</span>            <span class="comment"># 现在使用,可以用上面两行替换!</span></span><br><span class="line">        <span class="string">"one"</span>)</span><br><span class="line">                echo <span class="string">"Your choice is ONE"</span></span><br><span class="line">                ;;</span><br><span class="line">        <span class="string">"two"</span>)</span><br><span class="line">                echo <span class="string">"Your choice is TWO"</span></span><br><span class="line">                ;;</span><br><span class="line">        <span class="string">"three"</span>)</span><br><span class="line">                echo <span class="string">"Your choice is THREE"</span></span><br><span class="line">                ;;</span><br><span class="line">        *)</span><br><span class="line">                echo <span class="string">"Usage $&#123;0&#125; &#123;one|two|three&#125;"</span></span><br><span class="line">                ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><h4 id="4-4-3、-利用function功能"><a href="#4-4-3、-利用function功能" class="headerlink" title="4.4.3、 利用function功能"></a>4.4.3、 利用<code>function</code>功能</h4><p>什么是“函数 (function)”功能啊?简单的说,其实, 函数可以在 shell script 当中做出一个类似自订执行指令的东西,最大的功能是, 可以简化我们很多的程序码~举例来说,上面的show123.sh 当中,每个输入结果 one, two, three 其实输出的内容都一样啊~那么我就可以使用 function 来简化了! function 的语法是这样的:</p><pre><code>function fname(){    程序段}</code></pre><blockquote><p>  由于<code>shell script</code>的执行方式是由上而下,由左而右, 因此在<code>shell script</code>当中的<b style="color: red"><code>function</code>的设置一定要在程序的最前面</b>, 这样才能够在执行时被找到可用的程序段喔(这一点与传统程序语言差异相当大!初次接触的朋友要小心!)! 好~我们将上面的脚本改写<br>一下,自定义一个名为<code>printit</code>的函数来使用:</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2018/04/12    heany   First release</span></span><br><span class="line"></span><br><span class="line">PATH=<span class="regexp">/bin:/sbin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/local/bin</span><span class="symbol">:/usr/local/sbin</span><span class="symbol">:~/bin</span></span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line">function printit()&#123;</span><br><span class="line">        echo -n <span class="string">"Your choice is "</span>     <span class="comment"># 加上 -n 可以不换行继续在同一行显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo <span class="string">"This program will print your selection !"</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;</span><span class="number">1</span>&#125; <span class="keyword">in</span></span><br><span class="line">        <span class="string">"one"</span>)</span><br><span class="line">                printit; echo <span class="variable">$1</span> | tr <span class="string">'a-z'</span> <span class="string">'A-Z'</span>  <span class="comment"># 将参数做大小写转换!</span></span><br><span class="line">                ;;</span><br><span class="line">        <span class="string">"two"</span>)</span><br><span class="line">                printit; echo <span class="variable">$1</span> | tr <span class="string">'a-z'</span> <span class="string">'A-Z'</span></span><br><span class="line">                ;;</span><br><span class="line">        <span class="string">"three"</span>)</span><br><span class="line">                printit; echo <span class="variable">$1</span> | tr <span class="string">'a-z'</span> <span class="string">'A-Z'</span></span><br><span class="line">                ;;</span><br><span class="line">        *)      </span><br><span class="line">                echo <span class="string">"Usage $&#123;0&#125; &#123;one|two|three&#125;"</span></span><br><span class="line"><span class="string">"show123_function.sh"</span> <span class="number">29</span>L, <span class="number">591</span>C written                       <span class="number">11</span>,<span class="number">53</span>-<span class="number">55</span>      <span class="number">50</span>%</span><br></pre></td></tr></table></figure><h3 id="4-5、-循环（loop）"><a href="#4-5、-循环（loop）" class="headerlink" title="4.5、 循环（loop）"></a>4.5、 循环（<code>loop</code>）</h3><p>除了 if…then…fi 这种条件判断式之外,循环可能是程序当中最重要的一环了~ 循环可以不断的执行某个程序段落,直到使用者设置的条件达成为止。所以,重点是那个“条件的达成”是什么。除了这种依据判断式达成与否的不定循环之外,循环形态,可称为固定循环的形态呢!下面我们就来谈一谈:</p><h4 id="4-5-1、-while-do-done-until-do-done（不定循环）"><a href="#4-5-1、-while-do-done-until-do-done（不定循环）" class="headerlink" title="4.5.1、 while do done,until do done（不定循环）"></a>4.5.1、 <code>while do done</code>,<code>until do done</code>（不定循环）</h4><p>一般来说，不定循环最常见的就是下面这两种状态了：</p><pre><code>while [ condition ] &lt;=== 中括号内的状态就是判别式do    代码段done</code></pre><p><code>while</code>的中文是“当…时”，所以，这种方式说的是当<code>condition</code>条件成立时，就进行循环，直到<code>condition</code>的条件不成立才停止的意思。还有另为一种不定循环的方式：</p><pre><code>until [ condition ]do    代码段done</code></pre><p>这种方式恰恰与 while 相反,它说的是“当 condition 条件成立时,就终止循环, 否则就持续<br>进行循环的程序段。”是否刚好相反啊~我们以 while 来做个简单的练习好了。 假设我要让使<br>用者输入 yes 或者是 YES 才结束程序的执行,否则就一直进行告知使用者输入字串。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Program:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       Repeat question until user input correct answer.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> History:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2018/04/12    leagle  First release</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">while</span></span></span><br><span class="line">while [ "$yn" != "yes" -a "$yn" != "YES" ] </span><br><span class="line">do</span><br><span class="line">        read -p "Please input yes/YES to stop this program: " yn</span><br><span class="line">done    </span><br><span class="line">echo "OK! you input the correct answer."</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> until</span></span><br><span class="line">until [ "$yn" == "yes" -o "$yn" == "YES" ] </span><br><span class="line">do</span><br><span class="line">        read -p "Please input yes/YES to stop this program: " yn</span><br><span class="line">done</span><br><span class="line">echo "OK! you input the correct answer."</span><br></pre></td></tr></table></figure></p><h4 id="4-5-2、-for-do-done-固定循环"><a href="#4-5-2、-for-do-done-固定循环" class="headerlink" title="4.5.2、 for ... do ...done(固定循环)"></a>4.5.2、 <code>for ... do ...done</code>(固定循环)</h4><p><code>for</code>循环的语法如下所示：</p><pre><code>for var in con1 con2 con3 ...do    codedone</code></pre><p>简单练习。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Using for ... loop to print 3 animal.</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2018/04/12    leagle  First release</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> dog cat elephant</span><br><span class="line"><span class="keyword">do</span>      </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"There are <span class="variable">$&#123;animal&#125;</span>s ...."</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>让我们想像另外一种状况,由于系统上面的各种帐号都是写在 /etc/passwd 内的第一个字段,你能不能通过管线命令的 cut 捉出单纯的帐号名称后,以<code>id</code>分别检查使用者的识别码与特殊参数呢?由于不同的 Linux 系统上面的帐号都不一样!此时实际去捉<code>/etc/passwd</code>并使用循环处理,就是一个可行的方案了!程序可以如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Use id, finger command to check system account's information.</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2018/04/12    leagle  First release</span></span><br><span class="line"></span><br><span class="line">users=$(cut -d <span class="string">':'</span> -f1 ./pd.txt)         <span class="comment"># 提获帐号名称</span></span><br><span class="line"><span class="keyword">for</span> username <span class="keyword">in</span> <span class="variable">$&#123;users&#125;</span>        <span class="comment"># 开始循环进行!</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        id <span class="variable">$&#123;username&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>执行上面的脚本后,你的系统帐号就会被捉出来检查啦!这个动作还可以用在每个帐号的删除、重整上面呢! 换个角度来看,如果我现在需要一连串的数字来进行循环呢?举例来说,我想要利用 ping 这个可以判断网络状态的指令, 来进行网络状态的实际侦测时,我想要侦测的网域是本机所在的 192.168.1.1~192.168.1.100,由于有 100 台主机, 总不会要我在 for 后面输入 1 到 100 吧?此时你可以这样做喔!<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Use ping command to check the network's PC state.</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2018/04/12    leagle  First release</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">network</span>=<span class="string">"192.168.1"</span>     # 先定义一个网域的前面部分!</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sitenu <span class="keyword">in</span> $(seq 1 100)        # seq 为 sequence(连续) 的缩写之意</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        # 下面的程序在取得<span class="built_in"> ping </span>的回传值是正确的还是失败的!</span><br><span class="line">       <span class="built_in"> ping </span>-c 1 -w 1 <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> &amp;&gt; /dev/<span class="literal">null</span> &amp;&amp; <span class="attribute">result</span>=0 || <span class="attribute">result</span>=1</span><br><span class="line"></span><br><span class="line">        # 开始显示结果是正确的启动 (UP) 还是错误的没有连通 (DOWN)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;result&#125;</span>"</span> == 0 ]; then</span><br><span class="line">                echo <span class="string">"Server <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> is UP."</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                echo <span class="string">"Server <span class="variable">$&#123;network&#125;</span>.<span class="variable">$&#123;sitenu&#125;</span> is DOWN."</span></span><br><span class="line">        fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><blockquote><p> 注意那个<code>$(seq 1 100)</code>那个位置，那个是连续产生1-100个数。</p></blockquote><p>最后,让我们来玩判断式加上循环的功能!我想要让使用者输入某个目录文件名,然后我找出某目录内的文件名的权限,该如何是好?可以这样做啦~<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Use input dir name, I find the permission of files.</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2018/04/12    leagle  First release</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 先看看这个目录是否存在啊?</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input a directory: "</span> dir</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;dir&#125;</span>"</span> == <span class="string">""</span> -o ! -d <span class="string">"<span class="variable">$&#123;dir&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"The <span class="variable">$&#123;dir&#125;</span> is NOT exist in your system."</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 开始测试文件~</span></span><br><span class="line">filelist=$(ls <span class="variable">$&#123;dir&#125;</span>)   <span class="comment"># 列出所有在该目录下的文件名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> <span class="variable">$&#123;filelist&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        perm=<span class="string">""</span></span><br><span class="line">        <span class="built_in">test</span> -r <span class="string">"<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;filename&#125;</span>"</span> &amp;&amp; perm=<span class="string">"<span class="variable">$&#123;perm&#125;</span> readable"</span></span><br><span class="line">        <span class="built_in">test</span> -w <span class="string">"<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;filename&#125;</span>"</span> &amp;&amp; perm=<span class="string">"<span class="variable">$&#123;perm&#125;</span> writable"</span></span><br><span class="line">        <span class="built_in">test</span> -x <span class="string">"<span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;filename&#125;</span>"</span> &amp;&amp; perm=<span class="string">"<span class="variable">$&#123;perm&#125;</span> executable"</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"The file <span class="variable">$&#123;dir&#125;</span>/<span class="variable">$&#123;filename&#125;</span>'s permission is <span class="variable">$&#123;perm&#125;</span> "</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><h4 id="4-5-3-for-do-done的数值处理"><a href="#4-5-3-for-do-done的数值处理" class="headerlink" title="4.5.3 for ... do ...done的数值处理"></a>4.5.3 <code>for ... do ...done</code>的数值处理</h4><p>除了上述的方法之外，<code>for</code>循环还有另外一种写法，类似于<code>C语言</code>中的<code>for循环</code>！语法如下所示：</p><pre><code>for ((初始值;限制值;执行步长))do    codedone</code></pre><p>这种语法很适合用于数值方式的运算当中，值得注意的是,在“执行步阶”的设置上,如果每次增加 1 ,则可以使用类似<code>i++</code>的方式,亦即是 i 每次循环都会增加一的意思。好,我们以这种方式来进行 1 累加到使用者输入的循环吧!<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Program:</span></span><br><span class="line"><span class="comment">#       Try to calculate "1+2+3+...+$&#123;yourinput&#125;".</span></span><br><span class="line"><span class="comment"># History:</span></span><br><span class="line"><span class="comment"># 2018/04/12    leagle  First release</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Please input a number, I will count for 1+2+...+your_input: "</span> nu</span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line"><span class="keyword">for</span> (( i=1; i&lt;=<span class="variable">$nu</span>; i=i+1))</span><br><span class="line"><span class="keyword">do</span>      </span><br><span class="line">        s=$((<span class="variable">$s</span>+<span class="variable">$i</span>))</span><br><span class="line"><span class="keyword">done</span>    </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The result of '1+2+...+<span class="variable">$nu</span>' is ===&gt; <span class="variable">$s</span>"</span></span><br></pre></td></tr></table></figure></p><h3 id="4-6、-Shell-Script的追踪与Debug"><a href="#4-6、-Shell-Script的追踪与Debug" class="headerlink" title="4.6、 Shell Script的追踪与Debug"></a>4.6、 <code>Shell Script</code>的追踪与<code>Debug</code></h3><p><code>scripts</code>在执行之前,最怕的就是出现语法错误的问题了!那么我们如何<code>debug</code> 呢?有没有办法不需要通过直接执行该<code>scripts</code>就可以来判断是否有问题呢?呵呵!当然是有的!我们就直接以 bash 的相关参数来进行判断吧!</p><pre><code># 语法如下：sh [-nvx] scripts.sh# paras:-n ：不要执行script，仅查询语法的问题;-v ：在执行script之前，先将scripts的内容输出到屏幕上;-x ：将使用到的script内容显示到屏幕上，这是很有用的参数！</code></pre><p>一些范例测试：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bash -x ans_yn-<span class="number">2</span>.sh </span><br><span class="line">+ PATH=<span class="regexp">/bin:/sbin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/usr/local/bin</span><span class="symbol">:/usr/local/sbin</span><span class="symbol">:/home/heany/bin</span></span><br><span class="line">+ export PATH</span><br><span class="line">+ read -p <span class="string">'Please input (Y/N): '</span> yn</span><br><span class="line">Please input (Y/N): y</span><br><span class="line">+ <span class="string">'['</span> y == Y <span class="string">']'</span></span><br><span class="line">+ <span class="string">'['</span> y == y <span class="string">']'</span></span><br><span class="line">+ echo <span class="string">'OK, continue.'</span></span><br><span class="line">OK, continue.</span><br><span class="line">+ exit <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h2 id="五、-结束语"><a href="#五、-结束语" class="headerlink" title="五、 结束语"></a>五、 结束语</h2><p>&emsp;&emsp;这个系列终于结束了，码字调bug很辛苦哇～但是从中学到了很多有用的知识，解决了之前很多搞不清楚的问题，总之很棒啦！本文转载自<b>鸟哥的Linux私房菜：基础学习篇 第四版</b>。总之这本书非常适合入门学习～强烈推荐！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、-前言&quot;&gt;&lt;a href=&quot;#一、-前言&quot; class=&quot;headerlink&quot; title=&quot;一、 前言&quot;&gt;&lt;/a&gt;一、 前言&lt;/h2&gt;&lt;p&gt;最近开始使用Linux系统，经常操作terminal，经常使用Linux下的bash来进行一些重复的操作，因此想学习
      
    
    </summary>
    
      <category term="Script" scheme="http://heany.github.io/categories/Script/"/>
    
    
      <category term="Shell linux" scheme="http://heany.github.io/tags/Shell-linux/"/>
    
  </entry>
  
  <entry>
    <title>hexo常用命令</title>
    <link href="http://heany.github.io/2017/10/28/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://heany.github.io/2017/10/28/hexo常用命令/</id>
    <published>2017-10-28T06:18:08.000Z</published>
    <updated>2019-01-26T14:47:30.578Z</updated>
    
    <content type="html"><![CDATA[<p>现在来介绍常用的Hexo 命令</p><pre><code>npm install hexo -g #安装Hexonpm update hexo -g #升级 hexo init #初始化博客</code></pre><p>命令简写</p><pre><code>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</code></pre><blockquote><p> 博客搭建好以后，发表文章步骤及命令</p></blockquote><blockquote><ul><li>step1：切换到工作目录，执行<code>hexo n &quot;文章的title&quot;</code> , 然后看到<code>source/_posts</code>会出现刚刚新建的<code>文章的title.md</code></li><li>step2：进去编辑刚刚生成的md文件</li><li>step3：执行命令<code>hexo clean</code></li><li>step4: 执行命令<code>hexo g</code></li><li>step5: 执行命令<code>hexo d</code>等待一会就能看到博客主页出现了刚刚编写的文章</li></ul></blockquote><p>卸载hexo：</p><pre><code>npm uninstall hexo-cli -g #3.0.0版本执行npm uninstall hexo -g # 之前版本执行</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在来介绍常用的Hexo 命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo -g #安装Hexo
npm update hexo -g #升级 
hexo init #初始化博客
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令简写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;h
      
    
    </summary>
    
      <category term="Website" scheme="http://heany.github.io/categories/Website/"/>
    
    
      <category term="hexo常用命令" scheme="http://heany.github.io/tags/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>如何批量删除微博</title>
    <link href="http://heany.github.io/2017/10/28/%E5%A6%82%E4%BD%95%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E5%BE%AE%E5%8D%9A/"/>
    <id>http://heany.github.io/2017/10/28/如何批量删除微博/</id>
    <published>2017-10-28T05:44:52.000Z</published>
    <updated>2019-01-26T14:47:30.579Z</updated>
    
    <content type="html"><![CDATA[<!-->最近想删掉自己的所有微博，可是微博官方并没有相关的功能，网上也有一些工具能够实现，但是都收费。所以我搜了一些比较方便的方法，来实现删除所有微博。<a id="more"></a><blockquote><p> step1: 打开Chrome，新开一个标签页，进入我的微博“我的首页”</p></blockquote><blockquote><p> step2：打开Chrome的开发者工具（按F12）</p></blockquote><blockquote><p> step3: 点击console，打开控制台，将下面的代码贴进去，回车运行</p></blockquote><p><img src="http://static.zybuluo.com/Heany/ab4akric80zrgsp8bypxtnk3/weibo1.png" alt="打开开发者工具，点击console"></p><p><strong>将下面的代码贴近进console里</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         Weibored.js</span></span><br><span class="line"><span class="comment">// @namespace    http://vito.sdf.org</span></span><br><span class="line"><span class="comment">// @version      0.2.0</span></span><br><span class="line"><span class="comment">// @description  删除所有微博</span></span><br><span class="line"><span class="comment">// @match        http://weibo.com/p/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">s.setAttribute(</span><br><span class="line">  <span class="string">'src'</span>,</span><br><span class="line">  <span class="string">'https://lib.sinaapp.com/js/jquery/2.0.3/jquery-2.0.3.min.js'</span></span><br><span class="line">);</span><br><span class="line">s.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!$(<span class="string">'a[action-type="feed_list_delete"]'</span>)) &#123;</span><br><span class="line">      $(<span class="string">'a.next'</span>).click();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      $(<span class="string">'a[action-type="feed_list_delete"]'</span>)[<span class="number">0</span>].click();</span><br><span class="line">      $(<span class="string">'a[action-type="ok"]'</span>)[<span class="number">0</span>].click();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scroll bottom let auto load</span></span><br><span class="line">    $(<span class="string">'html, body'</span>).animate(&#123; <span class="attr">scrollTop</span>: $(<span class="built_in">document</span>).height() &#125;, <span class="string">'slow'</span>);</span><br><span class="line">  &#125;, <span class="number">800</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(s);</span><br></pre></td></tr></table></figure></p><p><img src="http://static.zybuluo.com/Heany/1ix1xrp45l4k28c2yiv9k28n/weibo2.png" alt="贴代码"></p><p><strong>回车运行</strong><br><img src="http://static.zybuluo.com/Heany/7lg9wxch0itn7e3vbga54b98/weibo3.png" alt="回车运行"></p><p><strong>此时能够看到微博主页开始滚动</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;!--&gt;
最近想删掉自己的所有微博，可是微博官方并没有相关的功能，网上也有一些工具能够实现，但是都收费。所以我搜了一些比较方便的方法，来实现删除所有微博。
    
    </summary>
    
      <category term="其他" scheme="http://heany.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>sublime插件：Markdown</title>
    <link href="http://heany.github.io/2017/10/15/sublime%E6%8F%92%E4%BB%B6%EF%BC%9AMarkdown/"/>
    <id>http://heany.github.io/2017/10/15/sublime插件：Markdown/</id>
    <published>2017-10-15T13:30:12.000Z</published>
    <updated>2019-01-26T14:47:30.579Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MarkDown-Editing：支持Markdown语法高亮；支持Github-Favored-Markdown语法；自带3个主题"><a href="#1-MarkDown-Editing：支持Markdown语法高亮；支持Github-Favored-Markdown语法；自带3个主题" class="headerlink" title="1.MarkDown Editing：支持Markdown语法高亮；支持Github Favored Markdown语法；自带3个主题"></a>1.<a href="https://github.com/SublimeText-Markdown/MarkdownEditing" target="_blank" rel="noopener">MarkDown Editing</a>：支持Markdown语法高亮；支持Github Favored Markdown语法；自带3个主题</h3><a id="more"></a><h3 id="2-MarkdownPreview：按CTRL-B生成网页HTML；在最前面添加-TOC-自动生成目录；"><a href="#2-MarkdownPreview：按CTRL-B生成网页HTML；在最前面添加-TOC-自动生成目录；" class="headerlink" title="2.MarkdownPreview：按CTRL + B生成网页HTML；在最前面添加[TOC]自动生成目录；"></a>2.<a href="https://github.com/revolunet/sublimetext-markdown-preview" target="_blank" rel="noopener">MarkdownPreview</a>：按<code>CTRL + B</code>生成网页HTML；在最前面添加[TOC]自动生成目录；</h3><h3 id="3-Markdown-Extended-Extends-Mononokai：不错的Markdown主题，支持对多种语言的高亮"><a href="#3-Markdown-Extended-Extends-Mononokai：不错的Markdown主题，支持对多种语言的高亮" class="headerlink" title="3.Markdown Extended + Extends Mononokai：不错的Markdown主题，支持对多种语言的高亮"></a>3.<a href="&#39;#&#39;">Markdown Extended + Extends Mononokai</a>：不错的Markdown主题，支持对多种语言的高亮</h3><h3 id="4-OmniMarkupPreviwer：实时在浏览器中预，而MarkdownPreview是需要手动生成的和F5的。览如果双屏的话，应该具有不错的体验。快捷键如下："><a href="#4-OmniMarkupPreviwer：实时在浏览器中预，而MarkdownPreview是需要手动生成的和F5的。览如果双屏的话，应该具有不错的体验。快捷键如下：" class="headerlink" title="4.OmniMarkupPreviwer：实时在浏览器中预，而MarkdownPreview是需要手动生成的和F5的。览如果双屏的话，应该具有不错的体验。快捷键如下："></a>4.<a href="http://theo.im/OmniMarkupPreviewer/" target="_blank" rel="noopener">OmniMarkupPreviwer</a>：实时在浏览器中预，而MarkdownPreview是需要手动生成的和F5的。览如果双屏的话，应该具有不错的体验。快捷键如下：</h3><ul><li><code>Ctrl+Alt+o</code>: Preview Markup in Browser</li><li><code>Ctrl+Alt+x</code>: Export Markup as HTML</li><li><code>Ctrl+Alt+c</code>: Copy Markup as HTML.</li></ul><h3 id="5-TableEditor：Markdown中的表格书写体验真心不咋样，所有有人为这个开发了一个插件，具有较好的自适应性，会自动对齐，强迫症患者喜欢。"><a href="#5-TableEditor：Markdown中的表格书写体验真心不咋样，所有有人为这个开发了一个插件，具有较好的自适应性，会自动对齐，强迫症患者喜欢。" class="headerlink" title="5.TableEditor：Markdown中的表格书写体验真心不咋样，所有有人为这个开发了一个插件，具有较好的自适应性，会自动对齐，强迫症患者喜欢。"></a>5.<a href="https://github.com/vkocubinsky/SublimeTableEditor" target="_blank" rel="noopener">TableEditor</a>：Markdown中的表格书写体验真心不咋样，所有有人为这个开发了一个插件，具有较好的自适应性，会自动对齐，强迫症患者喜欢。</h3><p>首先需要用<code>ctrl+shift+p</code>打开这个功能（Table Editor: Enable for current syntax or Table Editor: Enable for current view or “Table Editor: Set table syntax … for current view”），然后就可以狂用<code>tab</code>来自动完成了</p><h3 id="6-Markdown-TOC：编辑MD文件的时候可以查看自动生成，并且可以控制生产目录的层次，不过不会自动跳转。编辑的时候可以看看，如果需要生成的HTML具有超链接跳转的功能，还是用MarkdownPreview吧。"><a href="#6-Markdown-TOC：编辑MD文件的时候可以查看自动生成，并且可以控制生产目录的层次，不过不会自动跳转。编辑的时候可以看看，如果需要生成的HTML具有超链接跳转的功能，还是用MarkdownPreview吧。" class="headerlink" title="6.Markdown TOC：编辑MD文件的时候可以查看自动生成，并且可以控制生产目录的层次，不过不会自动跳转。编辑的时候可以看看，如果需要生成的HTML具有超链接跳转的功能，还是用MarkdownPreview吧。"></a>6.<a href="https://github.com/naokazuterada/MarkdownTOC" target="_blank" rel="noopener">Markdown TOC</a>：编辑MD文件的时候可以查看自动生成，并且可以控制生产目录的层次，不过不会自动跳转。编辑的时候可以看看，如果需要生成的HTML具有超链接跳转的功能，还是用<strong>MarkdownPreview</strong>吧。</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-MarkDown-Editing：支持Markdown语法高亮；支持Github-Favored-Markdown语法；自带3个主题&quot;&gt;&lt;a href=&quot;#1-MarkDown-Editing：支持Markdown语法高亮；支持Github-Favored-Markdown语法；自带3个主题&quot; class=&quot;headerlink&quot; title=&quot;1.MarkDown Editing：支持Markdown语法高亮；支持Github Favored Markdown语法；自带3个主题&quot;&gt;&lt;/a&gt;1.&lt;a href=&quot;https://github.com/SublimeText-Markdown/MarkdownEditing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MarkDown Editing&lt;/a&gt;：支持Markdown语法高亮；支持Github Favored Markdown语法；自带3个主题&lt;/h3&gt;
    
    </summary>
    
      <category term="常用工具" scheme="http://heany.github.io/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="sublime插件" scheme="http://heany.github.io/tags/sublime%E6%8F%92%E4%BB%B6/"/>
    
      <category term="Markdown" scheme="http://heany.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>如何上传本地文件到Github上</title>
    <link href="http://heany.github.io/2017/10/15/%E5%A6%82%E4%BD%95%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%88%B0Github%E4%B8%8A/"/>
    <id>http://heany.github.io/2017/10/15/如何上传本地文件到Github上/</id>
    <published>2017-10-15T13:14:57.000Z</published>
    <updated>2019-01-26T14:47:30.579Z</updated>
    
    <content type="html"><![CDATA[<!-->    最近做了一些工作，想将他们上传到GitHub上去保存，我习惯于本地编辑，完成后再一起上传到仓库中，长时间不使用很容易忘，总结网上的一些教程，写作博客里方便自己偶尔查阅。<a id="more"></a><p>本文参考以下博文<br><a href="http://www.jianshu.com/p/c70ca3a02087" target="_blank" rel="noopener">两种方法上传本地文件到github</a></p><p>想知道详细的步骤可以点击前往学习，这里我只简单记录一些常用的命令。</p><h4 id="1-GitHub在线上传文件夹"><a href="#1-GitHub在线上传文件夹" class="headerlink" title="1.GitHub在线上传文件夹"></a>1.GitHub在线上传文件夹</h4><h5 id="1-1点击Upload-files"><a href="#1-1点击Upload-files" class="headerlink" title="1.1点击Upload files"></a>1.1点击<code>Upload files</code></h5><h5 id="1-2-直接拖拽"><a href="#1-2-直接拖拽" class="headerlink" title="1.2 直接拖拽"></a>1.2 直接拖拽</h5><h4 id="2-通过git工具上传本地文件夹"><a href="#2-通过git工具上传本地文件夹" class="headerlink" title="2.通过git工具上传本地文件夹"></a>2.通过git工具上传本地文件夹</h4><h5 id="2-1下载git"><a href="#2-1下载git" class="headerlink" title="2.1下载git"></a>2.1下载git</h5><blockquote><p> 由于部分原因，国内直接官网下载git非常慢，需要FQ。这里提供一个国内的下载站，方便网友下载。</p></blockquote><p><a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener"><strong>点击前往</strong></a></p><h5 id="2-2-绑定用户"><a href="#2-2-绑定用户" class="headerlink" title="2.2 绑定用户"></a>2.2 绑定用户</h5><p>打开git-bash.exe（直接在桌面上点击右键，或者点击开始按钮找到Git Bash）</p><p>在打开的GIt Bash中输入以下命令（用户和邮箱为你github注册的账号和邮箱）</p><pre><code>$ git config --global user.name &quot;##&quot;$ git config --global user.email &quot;h##@**.com&quot;</code></pre><h5 id="2-3-设置SSH-Key"><a href="#2-3-设置SSH-Key" class="headerlink" title="2.3 设置SSH Key"></a>2.3 设置SSH Key</h5><h6 id="2-3-1-生成ssh-key"><a href="#2-3-1-生成ssh-key" class="headerlink" title="2.3.1 生成ssh key"></a>2.3.1 生成ssh key</h6><h6 id="2-3-2-为GitHub账号配置ssh-key"><a href="#2-3-2-为GitHub账号配置ssh-key" class="headerlink" title="2.3.2 为GitHub账号配置ssh key"></a>2.3.2 为GitHub账号配置ssh key</h6><h5 id="2-4-上传本地项目到GitHub"><a href="#2-4-上传本地项目到GitHub" class="headerlink" title="2.4 上传本地项目到GitHub"></a>2.4 上传本地项目到GitHub</h5><blockquote><p><strong>这里只贴一些命令</strong></p></blockquote><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 初始化</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="meta"># 将所有文件添加到仓库中</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta"># 提交</span></span><br><span class="line">git commit -m <span class="string">"注释"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 关联GitHub仓库</span></span><br><span class="line">git remote add origin https:<span class="comment">//github.com/**/##.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 上传本地代码及文件</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!--&gt;
    最近做了一些工作，想将他们上传到GitHub上去保存，我习惯于本地编辑，完成后再一起上传到仓库中，长时间不使用很容易忘，总结网上的一些教程，写作博客里方便自己偶尔查阅。
    
    </summary>
    
      <category term="Github" scheme="http://heany.github.io/categories/Github/"/>
    
    
  </entry>
  
  <entry>
    <title>在sublimeText3中安装pylinter方法</title>
    <link href="http://heany.github.io/2017/10/15/%E5%9C%A8sublimeText3%E4%B8%AD%E5%AE%89%E8%A3%85pylinter%E6%96%B9%E6%B3%95/"/>
    <id>http://heany.github.io/2017/10/15/在sublimeText3中安装pylinter方法/</id>
    <published>2017-10-15T06:03:54.000Z</published>
    <updated>2019-01-26T14:47:30.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-下载pylint安装包"><a href="#1-下载pylint安装包" class="headerlink" title="1.下载pylint安装包"></a>1.下载pylint安装包</h2><pre><code>官网下载，解压即可&lt;https://pypi.python.org/pypi/pylint&gt;</code></pre><h2 id="2-安装-astroid"><a href="#2-安装-astroid" class="headerlink" title="2.安装 astroid"></a>2.安装 astroid</h2><pre><code>pip install astroid</code></pre><p>或者<br>   &nbsp;&nbsp;&nbsp;&nbsp;打开<a href="https://bitbucket.org/logilab/astroid" target="_blank" rel="noopener">https://bitbucket.org/logilab/astroid</a>,下载压缩包，解压 cd到下载好的文件夹内，然后使用</p><pre><code>python setup.py install</code></pre><h2 id="3-安装isort-用如下命令"><a href="#3-安装isort-用如下命令" class="headerlink" title="3.安装isort,用如下命令"></a>3.安装isort,用如下命令</h2><pre><code>pip install isort</code></pre><h2 id="4-安装pylint"><a href="#4-安装pylint" class="headerlink" title="4.安装pylint"></a>4.安装pylint</h2><p>   &nbsp;&nbsp;&nbsp;&nbsp;cmd切换到刚才下载解压pylint文件夹内，输入命令：</p><pre><code>python setup.py install</code></pre><h2 id="5-安装pylint插件"><a href="#5-安装pylint插件" class="headerlink" title="5.安装pylint插件"></a>5.安装pylint插件</h2><blockquote><p>在sublime中ctrl+shift+P 然后输入install 然后输入pylinter，回车即可！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-下载pylint安装包&quot;&gt;&lt;a href=&quot;#1-下载pylint安装包&quot; class=&quot;headerlink&quot; title=&quot;1.下载pylint安装包&quot;&gt;&lt;/a&gt;1.下载pylint安装包&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;官网下载，解压即可&amp;lt;https
      
    
    </summary>
    
      <category term="常用工具" scheme="http://heany.github.io/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="sublime 插件" scheme="http://heany.github.io/tags/sublime-%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>python3.x与MySQL的安装与链接</title>
    <link href="http://heany.github.io/2017/10/15/python3-x%E4%B8%8EMySQL%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%93%BE%E6%8E%A5/"/>
    <id>http://heany.github.io/2017/10/15/python3-x与MySQL的安装与链接/</id>
    <published>2017-10-15T06:02:45.000Z</published>
    <updated>2019-01-26T14:47:30.578Z</updated>
    
    <content type="html"><![CDATA[<!--> 需要用到python来进行mysql数据库处理，遇到了一些问题，比如python如何连接MySQL进行数据库相关操作等，接下来我将一些python3中一些MySQL处理的一些操作写在下面。<a id="more"></a><blockquote><p>python2.x版本连接MySQL数据库需要安装MySQL-python库，打开终端输入命令：</p></blockquote><pre><code>pip install MySQL-python或者pip install MySQLdb</code></pre><blockquote><p>python3.x版本链接MySQL数据库需要安装PyMySQL库，打开终端输入命令：</p></blockquote><pre><code>pip install PyMySQL</code></pre><p>还可以通过Pycharm软件里面的库管理来添加pymysql<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql  </span><br><span class="line">      </span><br><span class="line"><span class="comment"># 连接数据库  </span></span><br><span class="line">connect = pymysql.Connect(  </span><br><span class="line">    host=<span class="string">'localhost'</span>,  </span><br><span class="line">    port=<span class="number">3306</span>,  </span><br><span class="line">    user=<span class="string">'root'</span>,  </span><br><span class="line">    passwd=<span class="string">'1234'</span>,  </span><br><span class="line">    db=<span class="string">'save'</span>,  </span><br><span class="line">    charset=<span class="string">'utf8'</span>  </span><br><span class="line"> )  </span><br><span class="line">      </span><br><span class="line"><span class="comment"># 获取游标  </span></span><br><span class="line">cursor = connect.cursor()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 插入数据  </span></span><br><span class="line">sql = <span class="string">"INSERT INTO money (name, account, saving) VALUES ( '%s', '%s', %.2f )"</span>  </span><br><span class="line">data = (<span class="string">'雷军'</span>, <span class="string">'13512345678'</span>, <span class="number">10000</span>)  </span><br><span class="line">cursor.execute(sql % data)  </span><br><span class="line">connect.commit()  </span><br><span class="line">print(<span class="string">'成功插入'</span>, cursor.rowcount, <span class="string">'条数据'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 修改数据  </span></span><br><span class="line">sql = <span class="string">"UPDATE money SET saving = %.2f WHERE account = '%s' "</span>  </span><br><span class="line">data = (<span class="number">8888</span>, <span class="string">'13512345678'</span>)  </span><br><span class="line">cursor.execute(sql % data)  </span><br><span class="line">connect.commit()  </span><br><span class="line">print(<span class="string">'成功修改'</span>, cursor.rowcount, <span class="string">'条数据'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查询数据  </span></span><br><span class="line">sql = <span class="string">"SELECT name,saving FROM money WHERE account = '%s' "</span>  </span><br><span class="line">data = (<span class="string">'13512345678'</span>,)  </span><br><span class="line">cursor.execute(sql % data)  </span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> cursor.fetchall():  </span><br><span class="line">    print(<span class="string">"Name:%s\tSaving:%.2f"</span> % row)  </span><br><span class="line">print(<span class="string">'共查找出'</span>, cursor.rowcount, <span class="string">'条数据'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除数据  </span></span><br><span class="line">sql = <span class="string">"DELETE FROM money  WHERE account = '%s' LIMIT %d"</span>  </span><br><span class="line">data = (<span class="string">'13512345678'</span>, <span class="number">1</span>)  </span><br><span class="line">cursor.execute(sql % data)  </span><br><span class="line">connect.commit()  </span><br><span class="line">print(<span class="string">'成功删除'</span>, cursor.rowcount, <span class="string">'条数据'</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 事务处理  </span></span><br><span class="line">sql_1 = <span class="string">"UPDATE money SET saving = saving + 1000 WHERE account = '18012345678' "</span>  </span><br><span class="line">sql_2 = <span class="string">"UPDATE money SET expend = expend + 1000 WHERE account = '18012345678' "</span>  </span><br><span class="line">sql_3 = <span class="string">"UPDATE money SET income = income + 2000 WHERE account = '18012345678' "</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    cursor.execute(sql_1)  <span class="comment"># 储蓄增加1000  </span></span><br><span class="line">    cursor.execute(sql_2)  <span class="comment"># 支出增加1000  </span></span><br><span class="line">    cursor.execute(sql_3)  <span class="comment"># 收入增加2000  </span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">    connect.rollback()  <span class="comment"># 事务回滚  </span></span><br><span class="line">    print(<span class="string">'事务处理失败'</span>, e)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    connect.commit()  <span class="comment"># 事务提交  </span></span><br><span class="line">    print(<span class="string">'事务处理成功'</span>, cursor.rowcount)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 关闭连接  </span></span><br><span class="line">cursor.close()  </span><br><span class="line">connect.close()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!--&gt;
 需要用到python来进行mysql数据库处理，遇到了一些问题，比如python如何连接MySQL进行数据库相关操作等，接下来我将一些python3中一些MySQL处理的一些操作写在下面。
    
    </summary>
    
      <category term="python" scheme="http://heany.github.io/categories/python/"/>
    
    
      <category term="python学习笔记" scheme="http://heany.github.io/tags/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>xpath学习笔记</title>
    <link href="http://heany.github.io/2017/10/15/xpath%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://heany.github.io/2017/10/15/xpath学习笔记/</id>
    <published>2017-10-15T06:00:09.000Z</published>
    <updated>2019-01-26T14:47:30.579Z</updated>
    
    <content type="html"><![CDATA[<!-->XPath是一个非常好用的解析方法，同时也作为爬虫学习的基础，在后面的 selenium 以及 scrapy 框架中都会涉及到这部分知识，需要把它的语法掌握清楚，为后面的深入研究做好铺垫。<a id="more"></a><h3 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h3><p>转自<a href="http://cuiqingcai.com/2621.html" target="_blank" rel="noopener">Python爬虫利器三之Xpath语法与lxml库的用法</a></p><p>xpath语法参考w3school</p><p><a href="http://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="noopener">w3school</a></p><h3 id="选取节点"><a href="#选取节点" class="headerlink" title="选取节点"></a>选取节点</h3><blockquote><p>XPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。</p></blockquote><h4 id="下面列出了最有用的路径表达式"><a href="#下面列出了最有用的路径表达式" class="headerlink" title="下面列出了最有用的路径表达式"></a>下面列出了最有用的路径表达式</h4><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">nodename</td><td style="text-align:center">选取此节点的所有子节点</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">从根结点选取</td></tr><tr><td style="text-align:center">//</td><td style="text-align:center">从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">选取当前节点</td></tr><tr><td style="text-align:center">..</td><td style="text-align:center">选取当前节点的父节点</td></tr><tr><td style="text-align:center">@</td><td style="text-align:center">选取属性</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><b>实例</b></h3><p>在下面的表格中，我们已经列出了一些路径表达式以及表达式的结果：</p><p><img src="http://static.zybuluo.com/Heany/pxue0b8hfzi64wtvzwbm2ng3/1.png" alt="1.png-13kB"></p><h3 id="实例Demo"><a href="#实例Demo" class="headerlink" title="实例Demo"></a>实例Demo</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>实例测试</strong></p><blockquote><p>在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：</p></blockquote><p><img src="http://static.zybuluo.com/Heany/xrja55z2gwunx21ji8qv9lgj/2.png" alt="2.png-13kB"></p><h3 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a><em>谓语</em></h3><pre><code>谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。</code></pre><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a><strong>实例</strong></h3><blockquote><p>在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：</p></blockquote><p><img src="http://static.zybuluo.com/Heany/zbzyg484qqbcxo9gbqdeoiqv/3.PNG" alt="3.PNG-31.6kB"></p><p><strong>选取未知节点</strong><br>XPath 通配符可用来选取未知的 XML 元素。</p><table><thead><tr><th style="text-align:center">通配符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">匹配任何节点元素</td></tr><tr><td style="text-align:center">@*</td><td style="text-align:center">匹配任何属性节点</td></tr><tr><td style="text-align:center">node()</td><td style="text-align:center">匹配任何类型的节点</td></tr></tbody></table><table><thead><tr><th style="text-align:center">通配符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">匹配任何节点元素</td></tr><tr><td style="text-align:center">@*</td><td style="text-align:center">匹配任何属性节点</td></tr><tr><td style="text-align:center">node()</td><td style="text-align:center">匹配任何类型的节点</td></tr></tbody></table><p>  <strong>实例</strong><br>  在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p><table><thead><tr><th style="text-align:center">路径表达式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">/bookstore/*</td><td style="text-align:center">选取bookstore元素的所有的子元素</td></tr><tr><td style="text-align:center">//*</td><td style="text-align:center">选取文档中的所有元素</td></tr><tr><td style="text-align:center">//title[@*]</td><td style="text-align:center">选取所有带有属性的title元素</td></tr></tbody></table><p>  <strong>选取若干路径</strong><br>  通过在路径表达式中使用“|”运算符，可以选择若干个路径<br>  <em>实例</em><br>  在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：</p><table><thead><tr><th style="text-align:center">路径表达式</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">//book/title \</td><td style="text-align:center">//book/price</td><td>选取 book 元素的所有 title 和 price 元素。</td></tr><tr><td style="text-align:center">//title \</td><td style="text-align:center">//price</td><td>选取文档中的所有 title 和 price 元素。</td></tr><tr><td style="text-align:center">/bookstore/book/title \</td><td style="text-align:center">//price</td><td>选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。</td></tr></tbody></table><h2 id="Xpath实例测试"><a href="#Xpath实例测试" class="headerlink" title="Xpath实例测试"></a><strong>Xpath实例测试</strong></h2><p>  测试Demo:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link1.html"</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link2.html"</span>&gt;</span>second item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-inactive"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link3.html"</span>&gt;</span>third item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-1"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link4.html"</span>&gt;</span>fourth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item-0"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"link5.html"</span>&gt;</span>fifth item<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><1> 获取所有的<code>&lt;l\&gt;</code>标签<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">response</span><span class="selector-class">.xpath</span>(<span class="string">'//li'</span>)</span><br></pre></td></tr></table></figure></1></p><p><2> 获取 <code>&lt;li&gt;</code> 标签的所有 class<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response.xpath(<span class="string">'//li/@class'</span>)</span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line"></span><br><span class="line">[<span class="string">'item-0'</span>, <span class="string">'item-1'</span>, <span class="string">'item-inactive'</span>, <span class="string">'item-1'</span>, <span class="string">'item-0'</span>]</span><br></pre></td></tr></table></figure></2></p><p><3> 获取 <code>&lt;li&gt;</code> 标签下 href 为 link1.html 的 <a> 标签<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.xpath('<span class="comment">//li/a[@href="link1.html"]')</span></span><br><span class="line"></span><br><span class="line">运行结果</span><br><span class="line"><span class="meta">[&lt;Element a at 0x10ffaae18&gt;]</span></span><br></pre></td></tr></table></figure></a></3></p><p><4> 获取 <code>&lt;li&gt;</code> 标签下的所有 <code>&lt;span&gt;</code> 标签</4></p><blockquote><p> 注意这种写法是不对的 </p></blockquote><pre><code>response.xpath(&apos;//li/span&apos;)</code></pre><blockquote><p>因为/是用来获取子元素的，而<span>并不是<code>&lt;li&gt;</code>的子元素，所以要用双斜杠，如下所示：</span></p></blockquote><pre><code>response.xpath(&apos;//li//span&apos;)</code></pre><p>运行结果：</p><pre><code>[&lt;Element span at 0x10d698e18&gt;]</code></pre><p><5> 获取<code>&lt;li&gt;</code>标签下的所有class，不包括<code>&lt;li&gt;</code></5></p><pre><code>result = response.xpath(&apos;&apos;//li/a/@class&apos;)print result</code></pre><p>运行结果：</p><pre><code>[&apos;blod&apos;]</code></pre><p><6> 获取最后一个<code>&lt;li&gt;</code>的<code>&lt;a&gt;</code>的href<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.xpath('<span class="comment">//li[last()]/a/@href')</span></span><br></pre></td></tr></table></figure></6></p><p>运行结果：</p><pre><code>[&apos;link5.html&apos;]</code></pre><p><7> 获取倒数第二个元素的内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = response.xpath(<span class="string">'//li[last()-1]/a'</span>)</span><br><span class="line"><span class="keyword">print</span> result[<span class="number">0</span>].text</span><br></pre></td></tr></table></figure></7></p><p>运行结果：</p><pre><code>fourth item</code></pre><p><8> 获取class为bold的标签名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = response.xpath(<span class="string">'//*[@class="bold"]'</span>)</span><br><span class="line"><span class="keyword">print</span> result[<span class="number">0</span>].tag</span><br></pre></td></tr></table></figure></8></p><p>运行结果：</p><pre><code>span</code></pre><blockquote><p>通过以上实例的练习，能够对XPath的基本用法有了基本的了解，也可以通过text()方法获取元素内容。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;!--&gt;
XPath是一个非常好用的解析方法，同时也作为爬虫学习的基础，在后面的 selenium 以及 scrapy 框架中都会涉及到这部分知识，需要把它的语法掌握清楚，为后面的深入研究做好铺垫。
    
    </summary>
    
      <category term="python" scheme="http://heany.github.io/categories/python/"/>
    
    
      <category term="python学习笔记" scheme="http://heany.github.io/tags/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>贝叶斯分类器实现</title>
    <link href="http://heany.github.io/2017/10/14/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://heany.github.io/2017/10/14/贝叶斯分类器实现/</id>
    <published>2017-10-14T11:03:31.000Z</published>
    <updated>2019-01-26T14:47:30.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、贝叶斯分类实现（采用python3-6-数据集为arff文件格式）"><a href="#1、贝叶斯分类实现（采用python3-6-数据集为arff文件格式）" class="headerlink" title="1、贝叶斯分类实现（采用python3.6 数据集为arff文件格式）"></a>1、贝叶斯分类实现（采用python3.6 数据集为arff文件格式）</h2><p>数据挖掘课老师留的一个实现贝叶斯分类器的练习，数据源为arff格式的文件~下面是使用python语言编写的一个简单的实现案例。<br><a id="more"></a></p><h2 id="1-1、-arff格式文件介绍"><a href="#1-1、-arff格式文件介绍" class="headerlink" title="1.1、 arff格式文件介绍"></a>1.1、 arff格式文件介绍</h2><p><a href="http://blog.sina.com.cn/s/blog_9d40b61301012xci.html" target="_blank" rel="noopener">参考链接</a></p><blockquote><p>arff文件是Weka默认的储存数据集文件。每个arff文件对应一个二维表格。表格的各行是数据集的各实例，各列是数据集的各个属性。推荐使用<code>UltraEdit</code>这样的字符编辑软件或者<strong>Sublime Text</strong>这样的文本编译器查看arff文件的内容。</p></blockquote><p>weather.arff 文件内容如下所示：<br><img src="http://static.zybuluo.com/Heany/x557l6ij8dord89b0lyjfsom/arff.png" alt="arff.png-25.6kB"></p><p>识别ARFF文件的重要依据是分行，因此不能在这种文件里随意的断行。空行（或全是空格的行）将被忽略。<br>以“%”开始的行是注释，WEKA将忽略这些行。如果你看到的“weather.arff”文件多了或少了些“%”开始的行，是没有影响的。<br>除去注释后，整个ARFF文件可以分为两个部分。第一部分给出了头信息（Head information），包括了对关系的声明和对属性的声明。第二部分给出了数据信息（Data information），即数据集中给出的数据。从“@data”标记开始，后面的就是数据信息了。<br>虽然Weka也支持其他一些格式的文件，但是ARFF格式是支持的最好的。因此有必要在数据处理之前把数据集的格式转换成ARFF。</p><h2 id="1-2、-arff格式文件读取"><a href="#1-2、-arff格式文件读取" class="headerlink" title="1.2、 arff格式文件读取"></a>1.2、 arff格式文件读取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readArff</span><span class="params">(fileName)</span>:</span>  </span><br><span class="line">    arffFile = open(fileName,<span class="string">'r'</span>)  </span><br><span class="line">    data = []  </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> arffFile.readlines():  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (line.startswith(<span class="string">'@'</span>)):  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (line.startswith(<span class="string">'%'</span>)):  </span><br><span class="line">                <span class="keyword">if</span> line !=<span class="string">'\n'</span>:  </span><br><span class="line">                    L=line.strip(<span class="string">'\n'</span>)  </span><br><span class="line">                    k=L.split(<span class="string">','</span>)  </span><br><span class="line">                    data.append(k)                      </span><br><span class="line">                    print(k)  </span><br><span class="line">    print(data)  </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">'__main__'</span>:  </span><br><span class="line">    fileName=<span class="string">r'C:\Users\Administrator\Desktop\exepirenment\classifill\data\weather.arff'</span>  </span><br><span class="line">    readArff(fileName)</span><br></pre></td></tr></table></figure><blockquote><p>输出结果如下所示：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">'sunny</span>', <span class="symbol">'85</span>', <span class="symbol">'85</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'no</span>']</span><br><span class="line">[<span class="symbol">'sunny</span>', <span class="symbol">'80</span>', <span class="symbol">'90</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'no</span>']</span><br><span class="line">[<span class="symbol">'overcast</span>', <span class="symbol">'83</span>', <span class="symbol">'86</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>']</span><br><span class="line">[<span class="symbol">'rainy</span>', <span class="symbol">'70</span>', <span class="symbol">'96</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>']</span><br><span class="line">[<span class="symbol">'rainy</span>', <span class="symbol">'68</span>', <span class="symbol">'80</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>']</span><br><span class="line">[<span class="symbol">'rainy</span>', <span class="symbol">'65</span>', <span class="symbol">'70</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'no</span>']</span><br><span class="line">[<span class="symbol">'overcast</span>', <span class="symbol">'64</span>', <span class="symbol">'65</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'yes</span>']</span><br><span class="line">[<span class="symbol">'sunny</span>', <span class="symbol">'72</span>', <span class="symbol">'95</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'no</span>']</span><br><span class="line">[<span class="symbol">'sunny</span>', <span class="symbol">'69</span>', <span class="symbol">'70</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>']</span><br><span class="line">[<span class="symbol">'rainy</span>', <span class="symbol">'75</span>', <span class="symbol">'80</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>']</span><br><span class="line">[<span class="symbol">'sunny</span>', <span class="symbol">'75</span>', <span class="symbol">'70</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'yes</span>']</span><br><span class="line">[<span class="symbol">'overcast</span>', <span class="symbol">'72</span>', <span class="symbol">'90</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'yes</span>']</span><br><span class="line">[<span class="symbol">'overcast</span>', <span class="symbol">'81</span>', <span class="symbol">'75</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>']</span><br><span class="line">[<span class="symbol">'rainy</span>', <span class="symbol">'71</span>', <span class="symbol">'91</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'no</span>']</span><br><span class="line">[[<span class="symbol">'sunny</span>', <span class="symbol">'85</span>', <span class="symbol">'85</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'no</span>'], [<span class="symbol">'sunny</span>', <span class="symbol">'80</span>', <span class="symbol">'90</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'no</span>'], [<span class="symbol">'overcast</span>', <span class="symbol">'83</span>', <span class="symbol">'86</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>'], [<span class="symbol">'rainy</span>', <span class="symbol">'70</span>', <span class="symbol">'96</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>'], [<span class="symbol">'rainy</span>', <span class="symbol">'68</span>', <span class="symbol">'80</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>'], [<span class="symbol">'rainy</span>', <span class="symbol">'65</span>', <span class="symbol">'70</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'no</span>'], [<span class="symbol">'overcast</span>', <span class="symbol">'64</span>', <span class="symbol">'65</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'yes</span>'], [<span class="symbol">'sunny</span>', <span class="symbol">'72</span>', <span class="symbol">'95</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'no</span>'], [<span class="symbol">'sunny</span>', <span class="symbol">'69</span>', <span class="symbol">'70</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>'], [<span class="symbol">'rainy</span>', <span class="symbol">'75</span>', <span class="symbol">'80</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>'], [<span class="symbol">'sunny</span>', <span class="symbol">'75</span>', <span class="symbol">'70</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'yes</span>'], [<span class="symbol">'overcast</span>', <span class="symbol">'72</span>', <span class="symbol">'90</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'yes</span>'], [<span class="symbol">'overcast</span>', <span class="symbol">'81</span>', <span class="symbol">'75</span>', <span class="symbol">'FALSE</span>', <span class="symbol">'yes</span>'], [<span class="symbol">'rainy</span>', <span class="symbol">'71</span>', <span class="symbol">'91</span>', <span class="symbol">'TRUE</span>', <span class="symbol">'no</span>']]</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="1-3、-实现贝叶斯分类器"><a href="#1-3、-实现贝叶斯分类器" class="headerlink" title="1.3、 实现贝叶斯分类器"></a>1.3、 实现贝叶斯分类器</h2><p><a href="http://blog.csdn.net/ben_ben_niao/article/details/40951843" target="_blank" rel="noopener"><strong><em>参考链接</em></strong></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re  </span><br><span class="line"><span class="keyword">import</span> sys  </span><br><span class="line"><span class="keyword">import</span> bisect  </span><br><span class="line">data =[]  <span class="comment">#全局变量  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readArff</span><span class="params">(fileName)</span>:</span>  </span><br><span class="line">    arffFile = open(fileName,<span class="string">'r'</span>)  </span><br><span class="line">    <span class="keyword">global</span> data  </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> arffFile.readlines():  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (line.startswith(<span class="string">'@'</span>)):  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (line.startswith(<span class="string">'%'</span>)):  </span><br><span class="line">                <span class="keyword">if</span> line !=<span class="string">'\n'</span>:  </span><br><span class="line">                    L=line.strip(<span class="string">'\n'</span>)  </span><br><span class="line">                    k=L.split(<span class="string">','</span>)  </span><br><span class="line">                    data.append(k)  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bayesion</span><span class="params">(testData)</span>:</span>  </span><br><span class="line">    class1=[]  </span><br><span class="line">    class2=[]  </span><br><span class="line">    <span class="keyword">global</span> data  </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:  </span><br><span class="line">        <span class="keyword">if</span> item[len(item)<span class="number">-1</span>] == <span class="string">'yes'</span>:  </span><br><span class="line">            class1.append(item)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            class2.append(item)  </span><br><span class="line">    class1Probability = len(class1) /len(data)  </span><br><span class="line">    class2Probability = len(class2) /len(data)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(testData)):  </span><br><span class="line">        count = <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> class1:  </span><br><span class="line">            <span class="keyword">if</span> testData[i]==elem[i]:  </span><br><span class="line">                count +=<span class="number">1</span>       <span class="comment">#统计个数  </span></span><br><span class="line">        class1Probability *= count/len(class1) <span class="comment">#累计乘法 求总概率  </span></span><br><span class="line">        count = <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> class2:  </span><br><span class="line">            <span class="keyword">if</span> testData[i]==elem[i]:  </span><br><span class="line">                count +=<span class="number">1</span>  </span><br><span class="line">        class2Probability *=count/len(class2)  </span><br><span class="line">    <span class="keyword">if</span> class1Probability &gt;class2Probability: <span class="comment">#比较，进而分类  </span></span><br><span class="line">        print(<span class="string">"The result is : Yes"</span>)  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        print(<span class="string">"The result if : No"</span>)  </span><br><span class="line"><span class="comment">#数据预处理，将data数据分箱，data数据为 list[list1,list2...]类型  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataPreprocessing1</span><span class="params">(data)</span>:</span>  </span><br><span class="line">    breakpoint1 =[<span class="number">70</span>,<span class="number">80</span>]  </span><br><span class="line">    breakpoint2=[<span class="number">80</span>,<span class="number">90</span>]  </span><br><span class="line">    newValue1=<span class="string">'LMH'</span>  </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:  </span><br><span class="line">        i = bisect.bisect(breakpoint1,int(item[<span class="number">1</span>])) <span class="comment">#int(),str()等类型需要转换  </span></span><br><span class="line">        item[<span class="number">1</span>]=str(newValue1[i])  </span><br><span class="line">        j = bisect.bisect(breakpoint2,int(item[<span class="number">2</span>]))  </span><br><span class="line">        item[<span class="number">2</span>]=str(newValue1[j])  </span><br><span class="line"><span class="comment">#数据预处理，分箱，针对单个list数据，data为list['..','..']类型  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataPreprocessing2</span><span class="params">(data)</span>:</span>  </span><br><span class="line">    breakpoint1 =[<span class="number">70</span>,<span class="number">80</span>]  </span><br><span class="line">    breakpoint2=[<span class="number">80</span>,<span class="number">90</span>]  </span><br><span class="line">    newValue1=<span class="string">'LMH'</span>  </span><br><span class="line">    i = bisect.bisect(breakpoint1,int(data[<span class="number">1</span>]))  </span><br><span class="line">    data[<span class="number">1</span>]=str(newValue1[i])  </span><br><span class="line">    j = bisect.bisect(breakpoint2,int(data[<span class="number">2</span>]))  </span><br><span class="line">    data[<span class="number">2</span>]=str(newValue1[j])  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">'__main__'</span>:  </span><br><span class="line">    fileName=<span class="string">r'C:\Users\Administrator\Desktop\exepirenment\classifill\data\weather.arff'</span>  </span><br><span class="line">    readArff(fileName)  </span><br><span class="line">    dataPreprocessing1(data)  </span><br><span class="line">  </span><br><span class="line">    testData =[<span class="string">'overcast'</span>,<span class="string">'72'</span>,<span class="string">'80'</span>,<span class="string">'TRUE'</span>]  </span><br><span class="line">    dataPreprocessing2(testData)  </span><br><span class="line">  </span><br><span class="line">    bayesion(testData)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、贝叶斯分类实现（采用python3-6-数据集为arff文件格式）&quot;&gt;&lt;a href=&quot;#1、贝叶斯分类实现（采用python3-6-数据集为arff文件格式）&quot; class=&quot;headerlink&quot; title=&quot;1、贝叶斯分类实现（采用python3.6 数据集为arff文件格式）&quot;&gt;&lt;/a&gt;1、贝叶斯分类实现（采用python3.6 数据集为arff文件格式）&lt;/h2&gt;&lt;p&gt;数据挖掘课老师留的一个实现贝叶斯分类器的练习，数据源为arff格式的文件~下面是使用python语言编写的一个简单的实现案例。&lt;br&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="http://heany.github.io/categories/Machine-Learning/"/>
    
    
      <category term="数据挖掘" scheme="http://heany.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="python3" scheme="http://heany.github.io/tags/python3/"/>
    
      <category term="贝叶斯分类器" scheme="http://heany.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>我的博客搭建流程</title>
    <link href="http://heany.github.io/2017/10/08/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>http://heany.github.io/2017/10/08/我的博客搭建流程/</id>
    <published>2017-10-08T12:42:48.000Z</published>
    <updated>2019-01-26T14:47:30.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><code>Hexo</code>部署到<code>GitHub</code>上的文件，是<code>.md</code>（你的博文）转化之后的<code>.html</code>（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写<code>html</code>）。<br><a id="more"></a><br>其实，<code>Hexo</code>生成的网站文件中有<code>.gitignore</code>文件，因此它的本意也是想我们将<code>Hexo</code>生成的网站文件存放到<code>GitHub</code>上进行管理的（而不是用U盘或者云备份啦）。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程，是极赞的。</p><p>但是，如果每一个<code>GitHub Pages</code>都需要创建一个额外的仓库来存放<code>Hexo</code>网站文件，我感觉很麻烦（10个项目需要20个仓库…）。</p><p>所以，我利用了分支！！！</p><p>简单地说，每个想建立<code>GitHub Pages</code>的仓库，起码有两个分支，一个用来存放<code>Hexo</code>网站的文件，一个用来发布网站。</p><p>下面将我的博客搭建流程简单讲一下</p><h2 id="二、-我的博客搭建流程"><a href="#二、-我的博客搭建流程" class="headerlink" title="二、 我的博客搭建流程"></a>二、 我的博客搭建流程</h2><ol><li>创建仓库，<code>yourname.github.io</code>;</li><li>创建两个分支: <code>master</code>（这个分支主要用来展示静态网页，给用户看的User Pages）和<code>hexo</code>（这个分支主要是用来备份Projects Pages）;</li><li>设置<code>hexo</code>为默认分支;</li><li>使用<code>git clone git@github.com:yourname/yourname.github.io</code>拷贝仓库，拷贝完成后，本地会有一个<code>yourname.github.com</code>文件夹;</li><li><p><strong>由于<code>hexo init dir</code>命令不能在非空的dir下执行成功</strong>,所以先找一个文件夹(例如<code>blog</code>)建立一个博客，也就是依次执行下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>将上面<code>blog</code>文件夹下所有的文件全部拷贝到刚刚<code>clone</code>下来的<code>yourname.github.io</code>文件夹里面。</p></li><li><p>修改<code>yourname.github.io/_config.yml</code>中的deploy参数，分支应该为<code>master</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:yourname/yourname.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></li><li><p>依次执行下面命令,将网站相关的文件备份到github上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"your comments"</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></li><li><p>然后执行<code>hexo</code>相关，命令生成网站，并部署到<code>Github</code>上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean #清楚缓存，若是网页正常情况下可以忽略这条命令</span><br><span class="line">hexo g  # 生成 是hexo generate</span><br><span class="line">hexo d  # 部署 是hexo deploy</span><br></pre></td></tr></table></figure></li></ol><blockquote><p> 如此操作，在<code>Github</code>上的<code>heany.github.io</code>仓库就有两个分支，一个<code>hexo</code>分支用来存放网站的原始文件，一个<code>master</code>分支用来存放生成的静态网页～效率超高，不用再新建一个repository去备份网站文件了！是不是很好～</p></blockquote><h2 id="三、-博客日常管理流程"><a href="#三、-博客日常管理流程" class="headerlink" title="三、 博客日常管理流程"></a>三、 博客日常管理流程</h2><h3 id="3-1、-日常修改"><a href="#3-1、-日常修改" class="headerlink" title="3.1、 日常修改"></a>3.1、 日常修改</h3><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p><ol><li>依次执行<code>git add .</code>、<code>git commit -m “…”</code>、<code>git push origin hexo</code>指令将改动推送到<code>GitHub</code>（此时当前分支应为<code>hexo</code>）；</li><li>然后才执行<code>hexo generate -d</code>发布网站到<code>master</code>分支上。</li></ol><p>虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</p><h3 id="3-2、-本地资料丢失"><a href="#3-2、-本地资料丢失" class="headerlink" title="3.2、 本地资料丢失"></a>3.2、 本地资料丢失</h3><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p><ol><li>使用<code>git clone git@github.com:yourname/yourname.github.io.git</code>拷贝仓库（默认分支为<code>hexo</code>）；</li><li>在本地新拷贝的<code>yourname.github.io</code>文件夹下通过<code>Git bash</code>(windows下使用。若是linux则在bash里面直接执行)依次执行下列指令：<code>npm install hexo</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>（<b style="color: red">记住不需要hexo init这条指令</b>）。</li></ol><h2 id="四、-结束语"><a href="#四、-结束语" class="headerlink" title="四、 结束语"></a>四、 结束语</h2><p><code>Github Pages</code>是<strong>支持域名绑定</strong>的，可以去<code>Godday</code>上买一个比较便宜的域名，然后在国内的<code>DNSPod</code>上去解析你的域名,。具体参考这篇文章<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">摸我前往</a>。</p><p>到这里结束了，好累啊～～～</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Hexo&lt;/code&gt;部署到&lt;code&gt;GitHub&lt;/code&gt;上的文件，是&lt;code&gt;.md&lt;/code&gt;（你的博文）转化之后的&lt;code&gt;.html&lt;/code&gt;（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了（除非你自己写&lt;code&gt;html&lt;/code&gt;）。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://heany.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hexo Github-Pages Blog" scheme="http://heany.github.io/tags/hexo-Github-Pages-Blog/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://heany.github.io/2017/10/08/hello-world/"/>
    <id>http://heany.github.io/2017/10/08/hello-world/</id>
    <published>2017-10-08T06:42:48.000Z</published>
    <updated>2019-01-26T14:47:30.578Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Hexo" scheme="http://heany.github.io/categories/Hexo/"/>
    
    
      <category term="hexo Blog" scheme="http://heany.github.io/tags/hexo-Blog/"/>
    
  </entry>
  
</feed>
